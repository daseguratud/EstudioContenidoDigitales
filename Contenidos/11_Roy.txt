Binary Number System 1
1.1 Introduction 1
1.2 Binary Number System 1
1.3 Representation of Numbers 2
1.3.1 Signed Magnitude Representation 2
1.3.2 One’s Complement Representation 3
1.3.3 Two’s Complement Representation 4
1.4 Binary Representation of Real Numbers 6
1.4.1 Fixed Point Data Format 6
1.5 Floating Point Data Format 7
1.6 Signed Number System 9
1.6.1 Binary SD Number System 9
1.6.2 SD Representation to Two’s Complement Representation 12
1.7 Conclusion 13
2 Basics of Verilog HDL 15
2.1 Introduction 15
2.2 Verilog Expressions 16
2.2.1 Verilog Operands 16
2.2.2 Verilog Operators 16
2.2.3 Concatenation and Replication 16
2.3 Data Flow Modelling 18
2.4 Behavioural Modelling 20
2.4.1 Initial Statement 20
2.4.2 Always Statement 21
2.4.3 Timing Control 21
2.4.4 Procedural Assignment 24
2.5 Structural Modelling 26
2.5.1 Gate-Level Modelling 26
2.5.2 Hierarchical Modelling 27
2.6 Mixed Modelling 28
2.7 Verilog Function 29
2.8 Verilog Task 30
2.9 File Handling 30
2.9.1 Reading from a Text File 31
2.9.2 Writing into a Text File 31
2.10 Test Bench Writing 32
2.11 Frequently Asked Questions 33
2.12 Conclusion 38
3 Basic Combinational Circuits 39
3.1 Introduction 39
3.2 Addition 39
3.3 Subtraction 41
3.4 Parallel Binary Adder 42
3.5 Controlled Adder/Subtractor 43
3.6 Multiplexers 44
3.7 De-Multiplexers 44
3.8 Decoders 45
3.9 Encoders 45
3.10 Majority Voter Circuit 46
3.11 Data Conversion Between Binary and Gray Code 47
3.12 Conversion Between Binary and BCD Code 48
3.12.1 Binary to BCD Conversion 49
3.12.2 BCD to Binary Conversion 51
3.13 Parity Generators/Checkers 52
3.14 Comparators 53
3.15 Constant Multipliers 55
3.16 Frequently Asked Questions 57
3.17 Conclusion 60
4 Basic Sequential Circuits 61
4.1 Introduction 61
4.2 Different Flip-Flops 61
4.2.1 SR Flip-Flop 62
4.2.2 JK Flip-Flop 63
4.2.3 D Flip-Flop 65
4.2.4 T Flip-Flop 67
4.2.5 Master-Slave D Flip-Flop 68
4.3 Shift Registers 68
4.3.1 Serial In Serial Out 69
4.3.2 Serial In Parallel Out 69
4.3.3 Parallel In Serial Out 70
4.3.4 Parallel In Parallel Out 71
4.4 Sequence Generator 72
4.5 Pseudo Noise Sequence Generator 73
4.6 Synchronous Counter Design 75
4.7 Loadable Counter 77
4.7.1 Loadable Up Counter 78
4.7.2 Loadable Down Counter 78
4.8 Even and Odd Counter 79
4.9 Shift Register Counters 80
4.10 Phase Generation Block 82
4.11 Clock Divider Circuits 82
4.11.1 Clock Division by Power of 2 83
4.11.2 Clock Division by 3 84
4.11.3 Clock Division by 6 85
4.11.4 Programmable Clock Divider Circuit 86
4.12 Frequently Asked Questions 86
4.13 Conclusion 88
5 Memory Design 89
5.1 Introduction 89
5.2 Controlled Register 89
5.3 Read OnlyMemory 90
5.3.1 Single Port ROM 90
5.3.2 Dual Port ROM(DPROM) 92
5.4 Random Access Memory (RAM) 93
5.4.1 Single Port RAM(SPRAM) 93
5.4.2 Dual Port RAM(DPRAM) 94
5.5 Memory Initialization 97
5.6 Implementing Bigger Memory Element Using Smaller Memory Elements 97
5.7 Implementation ofMemory Elements 98
5.8 Conclusion 100
6 Finite State Machines 101
6.1 Introduction 101
6.2 FSM Types 101
6.3 Sequence Detector Using Mealy Machine 103
6.4 Sequence Detector Using Moore Machine 107
6.5 Comparison of Mealy and Moore Machine 111
6.6 FSM-Based Serial Adder Design 111
6.7 FSM-Based Vending Machine Design 113
6.8 State Minimization Techniques 115
6.9 Row Equivalence Method 115
6.10 Implication ChartMethod 116
6.11 State Partition Method 119
6.12 Performance of State Minimization Techniques 120
6.13 Verilog Modelling of FSM-Based Systems 120
6.14 Frequently Asked Questions 123
6.15 Conclusion 126
7 Design of Adder Circuits 127
7.1 Introduction 127
7.2 Ripple Carry Adder 127
7.3 Carry Look-Ahead Adder 128
7.3.1 Higher Bit Adders Using CLA 130
7.3.2 Prefix Tree Adders 132
7.4 Manchester Carry Chain Module (MCC) 136
7.5 Carry Skip Adder 137
7.6 Carry Increment Adder 137
7.7 Carry Select Adder 137
7.8 Conditional Sum Adder 138
7.9 Ling Adders 139
7.10 Hybrid Adders 140
7.11 Multi-operand Addition 141
7.11.1 Carry Save Addition 141
7.11.2 Tree of Carry Save Adders 142
7.12 BCD Addition 142
7.13 Conclusion 144
8 Design of Multiplier Circuits 145
8.1 Introduction 145
8.2 Sequential Multiplication 145
8.3 Array Multipliers 146
8.4 Partial Product Generation and Reduction 149
8.4.1 Booth’s Multiplication 149
8.4.2 Radix-4 Booth’s Algorithm 150
8.4.3 Canonical Recoding 154
8.4.4 An Alternate 2-bit at-a-time Multiplication Algorithm 154
8.4.5 Implementing Larger Multipliers Using Smaller Ones 156
8.5 Accumulation of Partial Products 156
8.5.1 Accumulation of Partial Products for Unsigned Numbers 157
8.5.2 Accumulation of Partial Products for Signed Numbers 159
8.5.3 Alternative Techniques for Partial Product Accumulation 162
8.6 Wallace and Dedda Multiplier Design 163
8.7 Multiplication Using Look-Up Tables 167
8.8 Dedicated Square Block 168
8.9 Architectures Based on VEDIC Arithmetic 170
8.9.1 VEDIC Multiplier 170
8.9.2 VEDIC Square Block 171
8.9.3 VEDIC Cube Block 172
8.10 Conclusion 175
9 Division and Modulus Operation 177
9.1 Introduction 177
9.2 Sequential Division Methods 177
9.2.1 Restoring Division 178
9.2.2 Unsigned Array Divider 180
9.2.3 Non-restoring Division 181
9.2.4 Conversion from Signed Binary to Two’s Complement 184
9.3 Fast Division Algorithms 185
9.3.1 SRT Division 185
9.3.2 SRT Algorithm Properties 186
9.4 Iterative Division Algorithms 187
9.4.1 Goldschmidt Division 187
9.4.2 Newton–Raphson Division 187
9.5 Computation of Modulus 188
9.6 Conclusion 191
10 Square Root and its Reciprocal 193
10.1 Introduction 193
10.2 Slow Square Root Computation Methods 193
10.2.1 Restoring Algorithm 194
10.2.2 Non-restoring Algorithm 195
10.3 Iterative Algorithms for Square Root and its Reciprocal 197
10.3.1 Goldschmidt Algorithm 197
10.3.2 Newton–Raphson Iteration 198
10.3.3 Halley’sMethod 199
10.3.4 Bakhshali Method 199
10.3.5 Two Variable IterativeMethod 199
10.4 Fast SRT Algorithm for Square Root 200
10.5 Taylor Series Expansion Method 200
10.5.1 Theory 200
10.5.2 Implementation 202
10.6 Function Evaluation by Bipartite Table Method 203
10.7 Conclusion 205
11 CORDIC Algorithm 207
11.1 Introduction 207
11.2 Theoretical Background 207
11.3 VectoringMode 212
11.3.1 Computation of Sine and Cosine 213
11.4 Linear Mode 214
11.4.1 Multiplication 215
11.4.2 Division 215
11.5 Hyperbolic Mode 215
11.5.1 Square Root Computation 216
11.6 CORDIC Algorithm Using Redundant Number System 217
11.6.1 Redundant Radix-2-Based CORDIC Algorithm 217
11.6.2 Redundant Radix-4-Based CORDIC Algorithm 219
11.7 Example of CORDIC Iteration 219
11.8 Implementation of CORDIC Algorithms 219
11.8.1 Parallel Architecture 220
11.8.2 Serial Architecture 220
11.8.3 Improved CORDIC Architectures 222
11.9 Application 225
11.10 Conclusion 225
12 Floating Point Architectures 227
12.1 Introduction 227
12.2 Floating Point Representation 228
12.3 Fixed Point to Floating Point Conversion 230
12.4 Leading Zero Counter 231
12.5 Floating Point Addition 233
12.6 Floating Point Multiplication 236
12.7 Floating Point Division 238
12.8 Floating Point Comparison 239
12.9 Floating Point Square Root 240
12.10 Floating Point to Fixed Point Conversion 242
12.11 Conclusion 243
13 Timing Analysis 245
13.1 Introduction 245
13.2 Timing Definitions 246
13.2.1 Slew ofWaveform 246
13.2.2 Clock Jitter 246
13.2.3 Clock Latency 247
13.2.4 Launching and Capturing Flip-Flop 248
13.2.5 Clock Skew 248
13.2.6 Clock Uncertainty 249
13.2.7 Clock-to-Q Delay 249
13.2.8 Combinational Logic Timing 250
13.2.9 Min andMax Timing Paths 250
13.2.10 Clock Domains 251
13.2.11 Setup Time 251
13.2.12 Hold Time 251
13.2.13 Slack 252
13.2.14 Required Time and Arrival Time 253
13.2.15 Timing Paths 253
13.3 Timing Checks 253
13.3.1 Setup Timing Check 253
13.3.2 Hold Timing Check 254
13.4 Timing Checks for Different Timing Paths 254
13.4.1 Setup Check for Flip-Flop to Flip-Flop Timing Path 255
13.4.2 Setup and Hold Check for Input to Flip-Flop Timing Path 257
13.4.3 Setup Check for Flip-Flop to Output Timing Path 258
13.4.4 Setup Check for Input to Output Timing Path 258
13.4.5 Multicycle Paths 259
13.4.6 False Paths 260
13.4.7 Half Cycle Paths 260
13.5 Asynchronous Checks 261
13.5.1 Recovery Timing Check 261
13.5.2 Removal Timing Check 262
13.6 Maximum Frequency Computation 262
13.7 Maximum Allowable Skew 263
13.8 Frequently Asked Questions 266
13.9 Conclusion 268
14 Digital System Implementation 269
14.1 Introduction 269
14.2 FPGA Implementation 270
14.2.1 Internal Structure of FPGA 270
14.2.2 FPGA Implementation Using XILINX EDA Tool 276
14.2.3 Design Verification 279
14.2.4 FPGA Editor 280
14.3 ASIC Implementation 280
14.3.1 Simulation and Synthesis 281
14.3.2 Placement and Routing 283
14.4 Frequently Asked Questions 292
14.5 Conclusion 295
15 Low-Power Digital System Design 297
15.1 Introduction 297
15.2 Different Types of Power Consumption 297
15.2.1 Switching Power 298
15.2.2 Short Circuit Power 301
15.2.3 Leakage Power 301
15.2.4 Static Power 301
15.3 Architecture-Driven Voltage Scaling 302
15.3.1 Serial Architecture 302
15.3.2 Parallel Architecture 303
15.3.3 Pipeline Architecture 304
15.4 Algorithmic Optimization 304
15.4.1 Minimizing the Hardware Complexity 305
15.4.2 Selection of Data Representation Techniques 306
15.5 Architectural Optimization 307
15.5.1 Choice of Data Representation Techniques 307
15.5.2 Ordering of Input Signals 308
15.5.3 Reducing Glitch Activity 308
15.5.4 Choice of Topology 309
15.5.5 Logic Level Power Down 309
15.5.6 Synchronous Versus Asynchronous 309
15.5.7 Loop Unrolling 310
15.5.8 Operation Reduction 311
15.5.9 Substitution of Operation 313
15.5.10 Re-timing 314
15.5.11 Wordlength Reduction 316
15.5.12 Resource Sharing 316
15.6 Frequently Asked Questions 317
15.7 Conclusion 319
16 Digital System Design Examples 321
16.1 FPGA Implementation FIR Filters 322
16.1.1 FIR Low-Pass Filter 323
16.1.2 Advanced DSP Blocks 324
16.1.3 Different Filter Structures 325
16.1.4 Performance Estimation 330
16.1.5 Conclusion 332
16.1.6 Top Module for FIR Filter in Transposed Direct Form 332
16.2 FPGA Implementation of IIR Filters 333
16.2.1 IIR Low-Pass Filter 334
16.2.2 Different IIR Filter Structures 335
16.2.3 Pipeline Implementation of IIR Filters 338
16.2.4 Performance Estimation 342
16.2.5 Conclusion 344
16.3 FPGA Implementation of K-Means Algorithm 345
16.3.1 K-Means Algorithm 346
16.3.2 Example of K-Means Algorithm 347
16.3.3 Proposed Architecture 348
16.3.4 Design Performance 351
16.3.5 Conclusion 352
16.4 Matrix Multiplication 352
16.4.1 Matrix Multiplication by Scalar–Vector Multiplication 353
16.4.2 Matrix Multiplication by Vector–Vector Multiplication 354
16.4.3 Systolic Array for Matrix Multiplication 355
16.5 Sorting Architectures 359
16.5.1 Parallel Sorting Architecture 1 359
16.5.2 Parallel Sorting Architecture 2 359
16.5.3 Serial Sorting Architecture 360
16.5.4 Sorting Processor Design 361
16.6 Median Filter for Image De-noising 363
16.6.1 Median Filter 363
16.6.2 FPGA Implementation of Median Filter 365
16.7 FPGA Implementation of 8-Point FFT 367
16.7.1 Data Path for 8-Point FFT Processor 368
16.7.2 Control Path for 8-Point FFT Processor 370
16.8 Interfacing ADC Chips with FPGA Using SPI Protocol 371
16.9 Interfacing DAC Chips with FPGA Using SPI Protocol 378
16.10 Interfacing External Devices with FPGA Using UART 382
16.11 Conclusion 388
17 Basics of System Verilog 391
17.1 Introduction 391
17.2 Language Elements 391
17.2.1 Logic Literal Values 391
17.2.2 Basic Data Types 392
17.2.3 User Defined Data-Types 393
17.2.4 Enumeration Data Type 393
17.2.5 Arrays 394
17.2.6 Dynamic Arrays 395
17.2.7 Associative Array 396
17.2.8 Queues 396
17.2.9 Events 397
17.2.10 String Methods 397
17.3 Composite Data Types 398
17.3.1 Structures 398
17.3.2 Unions 400
17.3.3 Classes 401
17.4 Expressions 402
17.4.1 Parameters and Constants 402
17.4.2 Variables 403
17.4.3 Operators 404
17.4.4 SetMembership Operator 405
17.4.5 Static Cast Operator 405
xxii Contents
17.4.6 Dynamic Casting 406
17.4.7 Type Operator 407
17.4.8 Concatenation of String Data Type 407
17.4.9 Streaming Operators 407
17.5 Behavioural Modelling 408
17.5.1 Procedural Constructs 408
17.5.2 Loop Statements 410
17.5.3 Case Statement 413
17.5.4 If Statement 414
17.5.5 Final Statement 415
17.5.6 Disable Statement 416
17.5.7 Event Control 417
17.5.8 Continuous Assignment 417
17.5.9 Parallel Blocks 418
17.5.10 Process Control 419
17.6 Structural Modelling 420
17.6.1 Module Prototype 420
17.7 Summary 423
18 Advanced FPGA Implementation Techniques 425
18.1 Introduction 425
18.2 System-On-Chip Implementation 425
18.2.1 Implementations Using SoC FPGAs 427
18.2.2 AXI Protocol 430
18.2.3 AXI Protocol Features 431
18.3 Partial Re-configuration (PR) 432
18.3.1 Dynamic PR 432
18.3.2 Advantages of DPR 432
18.3.3 DPR Techniques 433
18.3.4 DPR Terminology 434
18.3.5 DPR Tools 436
18.3.6 DPR Flow 436
18.3.7 Communication Between Reconfigurable Modules 437
18.4 Conclusion 441
References 443
Index 447