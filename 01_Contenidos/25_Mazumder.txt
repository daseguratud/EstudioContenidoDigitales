Preface xi
Acknowledgement xv
List of Figures xvii
List of Tables xxix List of Abbreviations xxxi 1 Introduction 1
1.1 Objectives ........................... 1
1.1.1 Equationrepresentation ............... 1
1.1.2 Hardware platform implementation ......... 3
1.1.3 Sequentialdesign ................... 4
1.1.4 Datapathcomponents................. 6
1.1.5 Backendlectures ................... 6
1.2 Analogvs.Digital....................... 7
1.3 DigitalDesign......................... 11
1.3.1 Levelsofdigitaldesign................ 12
1.3.2 Whatdodigitaldesignersdo? ............ 13
2 Numeral Systems and BCD codes 17
2.1 Introduction.......................... 18
2.1.1 Unarynumeralsystems................ 18
2.1.2 The positional numeral system, or the place-value system ........................ 19
2.1.2.1 Binarynumbers .............. 19
2.1.2.2 Hexadecimal numbers ........... 20
2.1.2.3 Octalnumbers ............... 20
2.1.2.4 Converting from decimal to different bases 21
2.1.2.5 Converting from one arbitrary base (p) to anotherarbitrarybase(q) ......... 22
2.2 Addition and Subtraction in the Positional Numeral System . 24
2.3 NegativeNumbersinBinary ................. 26
2.3.1 Signedmagnitude .................. 26
2.3.2 The1’scomplement ................. 28
2.3.2.1 Addition in the 1’s complement ...... 30
2.3.2.2 Subtraction in the 1’s complement .... 31
2.3.3 The2’scomplement ................. 32
2.3.3.1 Addition in the 2’s complement ...... 34
2.3.3.2 Subtraction in the 2’s complement .... 35
2.4 Strings of Bits and Binary-Coded Decimal Representations . 36
2.4.1 The8421BCDcode ................. 36
2.4.2 The 2421, 631-1, 84-2-1, and Excess-3 BCD codes . 38
2.4.3 Thebiquinarycode .................. 39
2.4.4 Thegraycode..................... 39
2.4.5 BCDsummary .................... 43
2.5 MoreonNumberSystems .................. 44
2.6 ConclusionandKeyPoints .................. 46
3 Boolean Algebra and Logic Gates 51
3.1 Motivation........................... 52
3.2 HuntingtonPostulates..................... 52
3.3 BasicTheoremsofBooleanAlgebra ............. 53
3.3.1 Basicpostulateswith0and1............. 53
3.3.2 Idempotentlaws ................... 54
3.3.3 TheLawofinvolution ................ 54
3.3.4 Complementaritylaws ................ 54
3.3.5 Commutativelaws .................. 55
3.3.6 Associativelaws ................... 55
3.3.7 Distributivelaws ................... 55
3.3.8 DeMorgan’slaws ................... 56
3.4 Duality ............................ 59
3.4.1 What you should know from duality ......... 60
3.5 Logic Gates for Implementation of Boolean Networks .... 60
3.5.1 AND,OR,andNOT ................. 60
3.5.2 Implicantgates .................... 61
3.5.3 Otherlogicgates ................... 62
3.5.4 Equivalentgates ................... 65
3.5.5 Conceptofcompleteness ............... 67
3.6 CMOSGates ......................... 67
3.7 General Complementary Switching Network ......... 70
3.8 Conclusion .......................... 71
3.9 KeyPoints........................... 72
4 Timing Diagrams 79
4.1 NotionofTimingDelayinaCircuit ............. 80
4.2 DefinitionofPropagationDelay ............... 82
4.3 TimingDiagramsofaGatedLogic .............. 84
4.4 The Ring Oscillator: Good Use of Delays .......... 86
4.5 Glitches and Hazards: Bad Effects Due to Unequal Path Delays............................. 89
4.5.1 Correction of the static-1 hazard ........... 90
4.6 ConclusionandKeyPoints .................. 93
5 Combinational Logic Design Techniques: Part I 99
5.1 Designing a Digital System from a Problem Statement . . . 100
5.1.1 Stairwelllampproblem................ 100
5.1.2 BCD to seven-segment converter ........... 107
5.1.3 Eventdetector .................... 110
5.2 ConclusionandKeyPoints .................. 111
6 Combinational Logic Design Techniques: Part II 115
6.1 MajorityGateDesign ..................... 116
6.1.1 SOPimplementation ................. 117
6.1.2 POSimplementation ................. 119
6.1.3 Self-duality...................... 120
6.2 Why Different Representations: Two-Level Logic ImplementationStyles .................... 121
6.2.1 SOPrepresentations ................. 121
6.2.2 POSrepresentations ................. 122
6.2.3 Compatible representations for CMOS design .... 122
6.3 HardwareDescriptionLanguages............... 123
6.3.1 Majority gate and stairwell lamp verilog Implementation.................... 125
6.3.2 Full adder verilog implementation .......... 126
6.3.3 Ripplecarryadder .................. 126
6.4 ConclusionandKeyPoints .................. 127
7 Combinational Logic Minimization 135
7.1 Representation for Minimization: Summarization ...... 135
7.1.1 Intuitivedesignapproach............... 136
7.1.2 Booleanminimization ................ 136 
7.2 Graphical Method: The Karnaugh Map ............
137 7.3 Three-and Four-Variable Karnaugh Maps for Logic Circuits 139
7.4 Minimizing with Four-Variable K-maps 142
7.4.1 Formaldefinitions 143
7.4.2 Example 1: detailed illustration of minimization 7.4.3
Example 2: prime implicant definition reinforcement..................... 146
7.4.4 Example 3: dealing with “Don’t cares” ....... 146 
7.5 ConclusionandKeyPoints .................. 149
8 Combinational Building Blocks 155
8.1 Decoders ........................... 55
8.1.1 Implementation of larger-bit decoders ....... 156
8.1.2 Using decoders to implement boolean functions . . . 158
8.1.2.1 Example1 ................. 58
8.1.2.2 Example2 ................. 58
8.2 Multiplexers.......................... 60
8.2.1 Implementation of larger-bit multiplexers ...... 62
8.2.2 Using multiplexers to implement boolean functions ....................... 163
8.2.2.1 Example1 ................. 163
8.2.2.2 Example2 ................ 167
8.3 MSIBuildingBlocks ..................... 167
8.3.1 Decoders ....................... 167
8.3.1.1 The 74139 decoder ............ 167
8.3.1.2 The 74138 Decoder ............ 170
8.3.2 Tri-statebuffers.................... 170
8.3.2.1 Application ................ 171
8.3.2.2 The 74541 three-state driver ........ 173 
8.3.3 Encoders ....................... 173
8.3.3.1 The 74148 priority encoder ........ 174
8.3.3.2 Verilog implementation .......... 176 
8.3.4 Multiplexers ..................... 178
8.3.5 Paritycircuits ..................... 178
8.3.6 Comparisoncircuits ................. 181
8.3.6.1 Equality .................. 181
8.3.6.2 Greater than and less than ......... 182
8.3.6.3 The 74682 magnitude comparator IC . . . 182
8.4 Conclusion .......................... 183
8.5 KeyPoints........................... 183
9 Foundations of Sequential Design: Part I 191
9.1 TaxonomyofSequentialModels ............... 191
9.1.1 Themealymachine.................. 191
9.1.2 Themooremachine.................. 193
9.2 Flip-Flops........................... 193
9.2.1 Operation of flip-flops and their applications .... 193
9.2.2 Classification of flip-flops .............. 194
9.2.2.1 S-Rflip-flop ................ 194
9.2.2.1.1 Characteristic table ....... 194
9.2.2.1.2 Statediagram .......... 196
9.2.2.2 Tflip-flop ................. 197
9.2.2.2.1 Characteristic table ....... 197
9.2.2.2.2 Statediagram .......... 198
9.2.2.3 J-K flip-flop1................ 198
9.2.2.3.1 Characteristic table ....... 199
9.2.2.3.2 Statediagram .......... 200
9.2.2.4 Dflip-flop ................. 200
9.3 ConclusionandKeyPoints .................. 201
10 Foundations of Sequential Design: Part II 207
10.1 Gate Implementation of Flip-Flops and Timing Diagrams . . 208
10.1.1 Simple inverters without feedback .......... 208
10.1.2 Single inverter with feedback (oscillator) ...... 208
10.1.3 Two inverters with feedback (flip-flop) ........ 209
10.1.4 S-Rlatch ....................... 210
10.1.4.1 S-R latch timing diagram ......... 211
10.1.4.2 Problems with the S-R latch ........ 213
10.2ClockedFlip-Flops ...................... 214
10.2.1 ClockedS-Rflip-flop................. 215
10.2.2 ClockedJ-Kflip-flop ................. 216
10.2.2.1 J-K flip-flop timing diagram ........ 217
10.2.2.2 Problems with the J-K flip-flop ...... 218
10.2.3 Solutions to the race-around problem ........ 219
10.2.3.1 Narrowing the clock pulse width ..... 220
10.2.3.2 Separating the inputs and outputs of the flip-flop .................. 222
10.2.3.2.1 Master-Slave D flip-flop ..... 223
10.2.3.2.2 Master-Slave J-K flip-flop .... 224
10.2.4 IEEE symbols and flip-flop types .......... 228
10.2.5 Timing analysis of flip-flop problems ........ 230
10.2.5.1 Example 1: timing diagram of a J-K flip-flop 230
10.2.5.2 Example 2: timing diagram of J-K flip-flops configured as a counter/binary divider 231
10.2.5.3 Example 3: Timing diagram of D flip-flops configured as a ring counter ........ 232
10.2.6 Effectofthewidthofthesetpulse .......... 233
10.2.7 Dealing with metastability and asynchronous inputs . 234
10.3ConclusionandKeyPoint 235
10.4ProblemsonFlip-Flops 236
Index 243
About the Authors 247