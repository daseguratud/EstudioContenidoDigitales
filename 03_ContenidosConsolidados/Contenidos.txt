
->**********************************01_Flyod_en.txt
CHAPTER 1 Introductory Concepts 15
1-1 Digital and Analog Quantities 16
1-2 Binary Digits, Logic Levels, and Digital Waveforms 19
1-3 Basic Logic Functions 25
1-4 Combinational and Sequential Logic Functions 27
1-5 Introduction to Programmable Logic 34
1-6 Fixed-Function Logic Devices 40
1-7 Test and Measurement Instruments 43
1-8 Introduction to Troubleshooting 54
CHAPTER 2 Number Systems, Operations, and Codes 65
2-1 Decimal Numbers 66
2-2 Binary Numbers 67
2-3 Decimal-to-Binary Conversion 71
2-4 Binary Arithmetic 74
2-5 Complements of Binary Numbers 77
2-6 Signed Numbers 79
2-7 Arithmetic Operations with Signed Numbers 85
2-8 Hexadecimal Numbers 92
2-9 Octal Numbers 98
2-10 Binary Coded Decimal (BCD) 100
2-11 Digital Codes 104
2-12 Error Codes 109
CHAPTER 3 Logic Gates 125
3-1 The Inverter 126
3-2 The AND Gate 129
3-3 The OR Gate 136
3-4 The NAND Gate 140
3-5 The NOR Gate 145
3-6 The Exclusive-OR and Exclusive-NOR Gates 149
3-7 Programmable Logic 153
3-8 Fixed-Function Logic Gates 160
3-9 Troubleshooting 170
CHAPTER 4 Boolean Algebra and Logic Simplification 191
4-1 Boolean Operations and Expressions 192
4-2 Laws and Rules of Boolean Algebra 193
4-3 DeMorgan’s Theorems 199
11
12 Contents
4-4 Boolean Analysis of Logic Circuits 203
4-5 Logic Simplification Using Boolean Algebra 205
4-6 Standard Forms of Boolean Expressions 209
4-7 Boolean Expressions and Truth Tables 216
4-8 The Karnaugh Map 219
4-9 Karnaugh Map SOP Minimization 222
4-10 Karnaugh Map POS Minimization 233
4-11 The Quine-McCluskey Method 237
4-12 Boolean Expressions with VHDL 240
Applied Logic 244
CHAPTER 5 Combinational Logic Analysis 261
5-1 Basic Combinational Logic Circuits 262
5-2 Implementing Combinational Logic 267
5-3 The Universal Property of NAND and NOR gates 272
5-4 Combinational Logic Using NAND and NOR Gates 274
5-5 Pulse Waveform Operation 279
5-6 Combinational Logic with VHDL 283
5-7 Troubleshooting 288
Applied Logic 294
CHAPTER 6 Functions of Combinational Logic 313
6-1 Half and Full Adders 314
6-2 Parallel Binary Adders 317
6-3 Ripple Carry and Look-Ahead Carry Adders 324
6-4 Comparators 327
6-5 Decoders 331
6-6 Encoders 341
6-7 Code Converters 345
6-8 Multiplexers (Data Selectors) 347
6-9 Demultiplexers 356
6-10 Parity Generators/Checkers 358
6-11 Troubleshooting 362
Applied Logic 365
CHAPTER 7 Latches, Flip-Flops, and Timers 387
7-1 Latches 388
7-2 Flip-Flops 395
7-3 Flip-Flop Operating Characteristics 406
7-4 Flip-Flop Applications 409
7-5 One-Shots 414
7-6 The Astable Multivibrator 423
7-7 Troubleshooting 427
Applied Logic 429
Contents 13
CHAPTER 8 Shift Registers 449
8-1 Shift Register Operations 450
8-2 Types of Shift Register Data I/Os 451
8-3 Bidirectional Shift Registers 462
8-4 Shift Register Counters 465
8-5 Shift Register Applications 469
8-6 Logic Symbols with Dependency Notation 476
8-7 Troubleshooting 478
Applied Logic 480
CHAPTER 9 Counters 497
9-1 Finite State Machines 498
9-2 Asynchronous Counters 500
9-3 Synchronous Counters 507
9-4 Up/Down Synchronous Counters 515
9-5 Design of Synchronous Counters 519
9-6 Cascaded Counters 527
9-7 Counter Decoding 531
9-8 Counter Applications 534
9-9 Logic Symbols with Dependency Notation 539
9-10 Troubleshooting 541
Applied Logic 545
CHAPTER 10 Programmable Logic 561
10-1 Simple Programmable Logic Devices (SPLDs) 562
10-2 Complex Programmable Logic Devices (CPLDs) 567
10-3 Macrocell Modes 574
10-4 Field-Programmable Gate Arrays (FPGAs) 577
10-5 Programmable Logic software 585
10-6 Boundary Scan Logic 595
10-7 Troubleshooting 602
Applied Logic 608
CHAPTER 11 Data Storage 627
11-1 Semiconductor Memory Basics 628
11-2 The Random-Access Memory (RAM) 633
11-3 The Read-Only Memory (ROM) 646
11-4 Programmable ROMs 652
11-5 The Flash Memory 655
11-6 Memory Expansion 660
11-7 Special Types of Memories 666
11-8 Magnetic and Optical Storage 670
11-9 Memory Hierarchy 676
11-10 Cloud Storage 680
11-11 Troubleshooting 683
14 Contents
CHAPTER 12 Signal Conversion and Processing 697
12-1 Analog-to-Digital Conversion 698
12-2 Methods of Analog-to-Digital Conversion 704
12-3 Methods of Digital-to-Analog Conversion 715
12-4 Digital Signal Processing 723
12-5 The Digital Signal Processor (DSP) 724
CHAPTER 13 Data Transmission 739
13-1 Data Transmission Media 740
13-2 Methods and Modes of Data Transmission 745
13-3 Modulation of Analog Signals with Digital Data 750
13-4 Modulation of Digital Signals with Analog Data 753
13-5 Multiplexing and Demultiplexing 759
13-6 Bus Basics 764
13-7 Parallel Buses 769
13-8 The Universal Serial Bus (USB) 775
13-9 Other Serial Buses 778
13-10 Bus Interfacing 784
CHAPTER 14 Data Processing and Control 801
14-1 The Computer System 802
14-2 Practical Computer System Considerations 806
14-3 The Processor: Basic Operation 812
14-4 The Processor: Addressing Modes 817
14-5 The Processor: Special Operations 823
14-6 Operating Systems and Hardware 828
14-7 Programming 831
14-8 Microcontrollers and Embedded Systems 838
14-9 System on Chip (SoC) 844
ON WEBSITE: http://www.pearsonglobaleditions.com/floyd
CHAPTER 15 Integrated Circuit Technologies 855
15-1 Basic Operational Characteristics and Parameters 856
15-2 CMOS Circuits 863
15-3 TTL (Bipolar) Circuits 868
15-4 Practical Considerations in the Use of TTL 873
15-5 Comparison of CMOS and TTL Performance 880
15-6 Emitter-Coupled Logic (ECL) Circuits 881
15-7 PMOS, NMOS, and E2CMOS 883
ANSWERS TO ODD-NUMBERED PROBLEMS A-1
GLOSSARY A-31
INDEX A-42
->**********************************02_Tocci_en.txt
CHAPTER 1 Introductory Concepts
Introduction to Digital 1s and Os 4
Digital Signals 9
Need for Timing 10
Highs and Lows Over Time 11
Periodic/Aperiodic 11
Period/Frequency 11
Duty Cycle 12
Transitions 12
Edges/Events 12
Logic Circuits and Evolving Technology 13
Logic Circuits 13
Digital Integrated Circuits 14
Numerical Representations 14
Analog Representations 15
Digital Representations 15
Digital and Analog Systems 17
Advantages of Digital Techniques
Limitations of Digital Techniques 18
Digital Number Systems 19
Decimal System 19
Decimal Counting 20
Binary System 21
Binary Counting 22
Representing Signals with Numeric Quantities 23
Parallel and Serial Transmission 25
Memory 27
Digital Computers 28
Major Parts of aComputer 28
Types of Computers 29
Memory 30
Digital Progress Today and Tomorrow 31

CHAPTER 2 Number Systems and Codes 36
Binary-to-Decimal Conversions 38
Decimal-to-Binary Conversions 39
Counting Range 41
Hexadecimal Number System 41
Hex-to-Decimal Conversion 42
Decimal-to-Hex Conversion 43
Hex-to-Binary Conversion 43
Binary-to-Hex Conversion 44
Counting in Hexadecimal 44
Usefulness of Hex 44
Summary of Conversions 45
BCD Code 46
Binary-Coded-Decimal Code 46
Comparison of BCD and Binary 47
The Gray Code 48
Quadrature Encoders 50
Putting it All Together 51
The Byte, Nibble, and Word 52
Bytes 52
Nibbles 52
Words 53
Alphanumeric Codes 53
ASCII Code 54
Parity Method For Error Detection 56
Parity Bit 57
Error Correction 58
Applications 59

CHAPTER 3  Describing Logic Circuits 68
Boolean Constants and Variables 71
Truth Tables 72
OR Operation with OR Gates 73
OR Gate 74
Summary of the OR Operation 75
AND Operation with AND Gates 77
AND Gate 78
Summary of the AND Operation 79
NOT Operation 80
NOT Circuit (INVERTER) 81
Summary of Boolean Operations 81
Describing Logic Circuits
Algebraically 82
Operator Precedence 82
Circuits Containing INVERTERs 83
Evaluating Logic-Circuit Outputs 84
Analysis Using a Table 85
Implementing Circuits from Boolean
Expressions 87
NOR Gates and NAND Gates 88
NOR Gate 88
NAND Gate 90
Boolean Theorems 92
Multivariable Theorems 93

CHAPTER 4 Combinational
Logic Circuits 136
Sum-of-Products Form 138
Product-of-Sums 138
Simplifying Logic Circuits 139
Algebraic Simplification 140
Designing Combinational Logic
Circuits 145
Complete Design Procedure 147
Karnaugh Map Method 152
Karnaugh Map Format 152
Looping 154
Looping Groups of Two (Pairs) 154
Looping Groups of Four (Quads) 155
Looping Groups of Eight (Octets) 156
Complete Simplification Process 157
Filling a K Map from an Output
Expression 160



CHAPTER 5 Flip-Flops and Related Devices 236
NAND Gate Latch 239
Setting the Latch (FF) 240
Resetting the Latch (FF) 240
Simultaneous Setting and Resetting 241
Summary of NAND Latch 241
Alternate Representations 242
Terminology 242
NOR Gate Latch 245
Flip-Flop State on Power-Up 247
Troubleshooting Case Study 247
Digital Pulses 249
Clock Signals and Clocked Flip-Flops 251
Clocked Flip-Flops 252
Setup and Hold Times 252
Clocked S-R Flip-Flop 254
Internal Circuitry of the Edge-
Triggered S-R Flip-Flop 256
Clocked J-K Flip-Flop 258
Internal Circuitry of the Edge=
Triggered J-K Flip-Flop 259
Clocked D Flip=Flop 260
Implementation of the D Flip-Flop 261
Parallel Data Transfer 262
D Latch (Transparent Latch) 262
Asynchronous Inputs 264
Designations for Asynchronous
Inputs 266
Flip-Flop Timing Considerations 267
Setup and Hold Times 267
Propagation Delays 268
Maximum Clocking Frequency, fmax 268
Clock Pulse HIGH and LOW Times 268
Asynchronous Active Pulse Width 269
Clock Transition Times 269
Potential Timing Problem in FF Circuits 269
Flip-Flop Applications 271
Flip-Flop Synchronization 272
Detecting an Input Sequence 273
Detecting a Transition or “Event” 275
Data Storage and Transfer 276
Parallel Data Transfer 277
Serial Data Transfer: Shift Registers 278
Hold Time Requirement 279
Serial Transfer Between Registers 280
Shift-Left Operation 281
Parallel Versus Serial Transfer 281
Frequency Division and Counting 282
Counting Operation 283
State Transition Diagram 284
MOD Number 284
Application of Flip-Flops with Timing Constraints 286
Timing Issues 290
Microcomputer Application 293
Schmitt-Trigger Devices 294
One-Shot (Monostable Multivibrator) 296
Nonretriggerable One-Shot 296
Retriggerable One-Shot 297
Actual Devices 298
Monostable Multivibrator 298
Clock Generator Circuits 299
Schmitt-Trigger Oscillator 299
555 Timer Used as an Astable Multivibrator 299
Crystal-Controlled Clock Generators 302
Troubleshooting Flip-Flop Circuits 302
Open Inputs 303
Shorted Outputs 304
Clock Skew 305
Sequential Circuits in PLDs Using
Schematic Entry 307
Sequential Circuits Using HDL 311
The DLatch 314
Edge-Triggered Devices 315
HDL Circuits with Multiple
Components 320


CHAPTER 6 Digital Arithmetic: Operations and Circuits 340
Binary Addition and Subtraction 342
Binary Addition 342
Binary Subtraction 343
Representing Signed Numbers 343
1’s-Complement Form 344
2’s-Complement Form 345
Representing Signed Numbers Using
2’s Complement 345
Sign Extension 347
Negation 347
Special Case in 2’ssComplement
Representation 348
Addition in the 2’s-Complement
System 351
Subtraction in the 2’ssComplement
System 352
Arithmetic Overflow 353
Number Circles and Binary
Arithmetic 354
Multiplication of Binary Numbers 355
Multiplication in the 2’s-Complement System 356
Binary Division 357
BCD Addition 357
Sum Equals 9 or Less 358
Sum Greater than9 358
BCD Subtraction 359
Hexadecimal Arithmetic 360
Hex Addition 360
Hex Subtraction 361
Hex Representation of Signed Numbers 362
Arithmetic Circuits 363
Arithmetic/Logic Unit 363
Parallel Binary Adder 364
Design of a Full Adder 366
K=-Map Simplification 368
Half Adder 369
Complete Parallel Adder with
Registers 369
Register Notation 370
Sequence of Operations 371
Carry Propagation 372
Integrated-Circuit Parallel
Adder 373
Cascading Parallel Adders 373
2’s-Complement Circuits 375
Addition 375
Subtraction 375
Combined Addition and
Subtraction 377


CHAPTER 7 Counters and Registers 408
Asynchronous (Ripple) Counters 410
Signal Flow 411
MOD Number 412
Frequency Division 412
Duty Cycle 413
Propagation Delay in Ripple
Counters 414
Synchronous (Parallel) Counters 416
Circuit Operation 418
Advantage of Synchronous Counters
over Asynchronous 418
Actual ICs 418
Counters with Mod Numbers <2" 419
State Transition Diagram 421
Displaying Counter States 421
Changing the MOD Number 423
General Procedure 423
Decade Counters/BCD Counters 425
Synchronous Down and Up/Down
Counters 426
Presettable Counters 428
Synchronous Presetting 430
IC Synchronous Counters 430
The 74ALS160-163/74HC160-163
Series 430
The 74ALS190-191/74HC190-191
Series 434
Multistage Arrangement 439
Decoding a Counter 440
Active-HIGH Decoding 441
Active-LOW Decoding 442
BCD Counter Decoding 442
Analyzing Synchronous Counters 444
Synchronous Counter Design 447
Basic Idea 447
J-K Excitation Table 448
Design Procedure 449
Stepper Motor Control 452
Synchronous Counter Design
with DFF 454
Altera Library Functions for Counters 45€
HDL Counters 460
State Transition Description
Methods 461
Behavioral Description 464
Simulation of Basic Counters 467
Full-Featured Counters in HDL 467
Simulation of Full-Featured
Counter 471
Wiring HDL Modules Together 473
MOD-100 BCD Counter 476
State Machines 481
Simulation of State Machines 484
Traffic Light Controller State
Machine 485
Choosing HDL Coding Techniques 491
Register Data Transfer 493
IC Registers 493
Parallel In/Parallel Out—The 74ALS174/74HC174 494
Serial In/Serial Out—The74ALS166/74HC166 496
Parallel In/Serial Out—The 74ALS165/74HC165 498
Serial In/Parallel Out—The 74ALS164/74HC164 500
Shift-Register Counters 502
Ring Counter 502
Starting a Ring Counter 502
Johnson Counter 503
Decoding a Johnson Counter 505
IC Shift-Register Counters 506
Troubleshooting 506
Megafunction Registers 509
HDL Registers 513
HDL Ring Counters 519
HDL One-Shots 521
Nonretriggerable One-Shot Simulation 523
Retriggerable, Edge-Triggered One-Shots in HDL 524
Edge-Triggered Retriggerable One-Shot Simulation 527


CHAPTER 8 _Integrated-Circuit
Logic Families 550
Digital IC Terminology 552
Current and Voltage Parameters (See Figure 8-1) 552
Fan-Out 553
Propagation Delays 554
Power Requirements 554
Noise Immunity 555
Invalid Voltage Levels 557
Current-Sourcing and Current-Sinking
Action 557
IC Packages 558
The TTL Logic Family 561
Circuit Operation—LOW State 561
Circuit Operation==HIGH State 562
Current-Sinking Action 564
Current=-Sourcing Action 564
Totem-Pole Output Circuit 564
TTL NOR Gate 565
Summary 565
TTL Data Sheets 566
Supply Voltage and Temperature Range 567
Voltage Levels 567
Maximum Voltage Ratings 568
Power Dissipation 568
Propagation Delays 568
TTL Series Characteristics 569
Standard TTL, 74 Series 570
Schottky TTL, 74S Series 570
Low-Power Schottky TTL, 74LS Series (LS-TTL) 571
Advanced Schottky TTL, 74AS Series (AS-TTL) 571
Advanced Low-Power Schottky TTL,74ALS Series 571
74F—Fast TTL 571
Comparison of TTL Series Characteristics 572
TTL Loading and Fan-Out 573
Determining the Fan-Out 574
Other TTL Characteristics 578
Unconnected Inputs (Floating) 578
Unused Inputs 578
Tied-Together Inputs 579
Biasing TTL Inputs Low 580
Current Transients 581
MOS Technology 582
The MOSFET 583
Basic MOSFET Switch 583
Complementary MOS Logic 585
CMOS Inverter 586
CMOS NAND Gate 586
CMOS NOR Gate 587
CMOS SET-RESET FF 588
CMOS Series Characteristics 588
4000/14,000 Series 588
74HC/HCT (High-Speed CMOS) 589
74AC/ACT (Advanced CMOS) 589
74AHC/AHCT (Advanced High-Speed CMOS) 589
BiCMOS 5-V Logic 589
Power-Supply Voltage 590
Logic Voltage Levels 590
Noise Margins 590
Power Dissipation 591
Pp Increases with Frequency 591
Fan-Out 592
Switching Speed 592
Unused Inputs 593
Static Sensitivity 593
Latch-Up 594
Low-Voltage Technology 594
CMOS Family 595
BiCMOS Family 596
Open-Collector/Open-Drain Outputs 597
Open-Collector/Open-Drain Outputs 598
Open-Collector/Open-Drain Buffer/
Drivers 600
IEEE/ANSI Symbol for Open-Collector/Drain Outputs 601
Tristate (Three-State) Logic Outputs 602
Advantage of Tristate 602
Tristate Buffers 603
Tristate ICs 605
TEEE/ANSI Symbol for Tristate Outputs 605
High-Speed Bus Interface Logic 605
CMOS Transmission Gate (Bilateral Switch) 607
IC Interfacing 609
Interfacing 5-V TTL and CMOS 611
CMOS Driving TTL 612
CMOS Driving TTL in the HIGH State 612
CMOS Driving TTL in the LOW State 612
Mixed-Voltage Interfacing 614
Low-Voltage Outputs Driving High-Voltage Loads 614
High-Voltage Outputs Driving Low-Voltage Loads 614
Analog Voltage Comparators 616
Troubleshooting 617
Using a Logic Pulser and Probe to Testa Circuit 618
Finding Shorted Nodes 618
Characteristics of an FPGA 619
Power-Supply Voltage 619
Logic Voltage Levels 620
Power Dissipation 620
Maximum Input Voltage and Output Current Ratings 621
Switching Sneed 621
CHAPTER 9 MSI Logic Circuits 638
Decoders 639
ENABLE Inputs 640
BCD-to-Decimal Decoders 644
BCD-to-Decimal Decoder/Driver 645
Decoder Applications 645
BCD-to-7-Segment Decoder/Drivers 647
Common-Anode Versus Common-Cathode
LED Displays 648
Liquid-Crystal Displays 649
Driving an LCD 650
Types of LCDs 651
Encoders 653
Priority Encoders 655
74147 Decimal-to-BCD Priority Encoder 655
Switch Encoder 656
Troubleshooting 659
Multiplexers (Data Selectors) 662
Basic Two-Input Multiplexer 663
Four-Input Multiplexer 664
Eight-Input Multiplexer 664
Quad Two-Input MUX (74ALS157/HC157) 666
Multiplexer Applications 668
Data Routing 668
Parallel-to-Serial Conversion 669
Operation Sequencing 669
Logic Function Generation 672
Demultiplexers (Data Distributors) 673
1-Line-to-8-Line Demultiplexer 674
Security Monitoring System 675
Synchronous Data Transmission System 677
Time Division Multiplexing 679
More Troubleshooting 683
Magnitude Comparator 687
Data Inputs 688
Outputs 688
Cascading Inputs 688
Applications 689
Code Converters 690
Basic Idea 691
Conversion Process 691
Circuit Implementation 692
Other Code Converter
Implementations 694
Data Busing 694
The 74ALS173/HC173 Tristate Register 696
Data Bus Operation 698
Data Transfer Operation 699
Bus Signals 700
Simplified Bus Timing Diagram 701
Expanding the Bus 701
Simplified Bus Representation 703
Bidirectional Busing 704
Decoders Using HDL 705
The HDL 7-Segment Decoder/Driver 709
Encoders Using HDL 712
HDL Multiplexers and Demultiplexers 716
HDL Magnitude Comparators 720
HDL Code Converters 721
CHAPTER 10 Digital System
Projects Using HDL 744
Small-Project Management 746
Definition 746
Strategic Planning/Problem Decomposition 746
Synthesis and Testing 747
System Integration and Testing 747
Stepper Motor Driver Project 747
Problem Definition 748
Strategic Planning/Problem Decomposition 749
Synthesis and Testing 750
Keypad Encoder Project 755
Problem Analysis 755
Strategic Planning/Problem Decomposition 757
Digital Clock Project 761
Top-Down Hierarchical Design 764
Building the Blocks from the Bottom Up 766
MOD-12 Design 769
Combining Blocks Graphically 773
Combining Blocks Using Only
HDL 774
Microwave Oven Project 778
Definition of the Project 779
Strategic Planning/Problem
Decomposition 780
Synthesis/Integration and
Testing 784
Frequency Counter Project 785
CHAPTER 11 Interfacing with the
Analog World 794
Review of Digital Versus Analog 795
Digital-to-Analog Conversion 797
Analog Output 799
Input Weights 799
Resolution (Step Size) 800
Percentage Resolution 801
What Does Resolution Mean? 802
Bipolar DACs 804
DAC Circuitry 804
Conversion Accuracy 806
DAC with Current Output 806
R/2R Ladder 808
DAC Specifications 810
Resolution 810
Accuracy 810
Offset Error 811
Settling Time 811
Monotonicity 811
An Integrated-Circuit DAC 812
DAC Applications 813
Control 813
Automatic Testing 813
Signal Reconstruction 813
A/D Conversion 813
Digital Amplitude Control 813
Serial DACs 814
Troubleshooting DACs 814
Analog-to-Digital Conversion 816
Digital-Ramp ADC 817
A/D Resolution and Accuracy 820
Conversion Time, tc 821
Data Acquisition 822
Reconstructing a Digitized Signal 824
Aliasing 825
Serial ADCs 826
Successive-Approximation ADC 826
Conversion Time 829
An Actual IC: The ADC0804 Successive - Approximation ADC 829
Flash ADCs 834
Conversion Time 836
Other A/D Conversion Methods 836
Dual-Slope Integrating ADC 837
Voltage-to-Frequency ADC 838
Sigma/Delta Modulation 838
Pipelined ADC 840
Typical ADC Architectures for Applications 842
Sample-and-Hold Circuits 843
Multiplexing 844
Digital Signal Processing (DSP) 845
Digital Filtering 846
Applications of Analog Interfacing 849
Data Acquisition Systems 849
Digital Camera 850
Digital Cellular Telephone 850
CHAPTER 12 Memory Devices 866
Memory Terminology 868
General Memory Operation 872
Address Inputs 873
The WE Input 873
Output Enable (OE) 874
Memory Enable 874
CPU-Memory Connections 875
Read-Only Memories 877
ROM Block Diagram 877
The Read Operation 878
ROM Architecture 879
Register Array 880
Address Decoders 880
Output Buffers 880
ROM Timing 881
Types of ROMs 882
Mask-Programmed ROM 883
Programmable ROMs (PROMs) 885
Erasable Programmable ROM (EPROM) 886
Electrically Erasable PROM (EEPROM) 887
Flash Memory 889
A Typical CMOS Flash MemoryIC 890
Flash Technology: NOR and NAND 891
ROM Applications 894
Embedded Microcontroller Program Memory 894
Data Transfer and Portability 894
Bootstrap Memory 894
Data Tables 895
Data Converter 895
Function Generator 895
Semiconductor RAM 896
RAM Architecture 897
Read Operation 898
Write Operation 898
Chip Select 898
Common Input/Output Pins 898
Static RAM (SRAM) 899
Static-RAM Timing 900
Read Cycle 900
Write Cycle 902
Dynamic RAM (DRAM) 902
Dynamic RAM Structure and Operation 904
Address Multiplexing 905
DRAM Read/Write Cycles 909
DRAM Read Cycle 909
DRAM Write Cycle 910
DRAM Refreshing 910
DRAM Technology 913
Memory Modules 913
FPM DRAM 914
EDO DRAM 914
SDRAM 914
DDRSDRAM 914
Other Memory Technologies 915
Magnetic Storage 915
Optical Memory 916
Phase Change Ram (PRAM) 917
Ferroelectric RAM (FRAM) 917
Expanding Word Size and Capacity 917
Expanding Word Size 918
Expanding Capacity 920
Incomplete Address Decoding 923
Combining DRAM Chips 924
Special Memory Functions 925
Cache Memory 926
First-In, First-Out Memory (FIFO) 927
Circular Buffers 928

CHAPTER 13 Programmable
Logic Device
Architectures 940
Digital Systems Family Tree 942
More on PLDs 944
Fundamentals of PLD Circuitry 948
PLD Symbology 949
PLD Architectures 950
PROMs 950
Programmable Array Logic (PAL) 951
Field Programmable Logic Array (FPLA) 954
Generic Array Logic (GAL) 954
The Altera MAX and MAX II Families 955
Generations of HCPLDs 958
Glossary 962
Answers to Selected Problems 975
Index of ICs 983
Index 986

->**********************************03_Roth_en.txt
How to Use This Book for Self-Study
Digital Resources 
About the Authors 
Unit 1 Introduction
Number Systems and Conversion 1
Objectives 1
Study Guide 2
1.1 Digital Systems and Switching Circuits 6
1.2 Number Systems and Conversion 8
1.3 Binary Arithmetic 12
1.4 Representation of Negative Numbers 16
Sign and Magnitude Numbers 16
2’s Complement Numbers 16
Addition of 2’s Complement Numbers 17
1’s Complement Numbers 19
Addition of 1’s Complement Numbers 19
1.5 Binary Codes 21
Problems 24
Unit 2 Boolean Algebra 29
Objectives 29
Study Guide 30
2.1 Introduction 36
2.2 Basic Operations 37
2.3 Boolean Expressions and Truth Tables 39
2.4 Basic Theorems 41
2.5 Commutative, Associative, Distributive, and DeMorgan’s Laws 43
2.6 Simplification Theorems 46
2.7 Multiplying Out and Factoring 49
2.8 Complementing Boolean Expressions 52
Problems 53
Unit 3 Boolean Algebra (Continued) 60
Objectives 60
Study Guide 61
3.1 Multiplying Out and Factoring Expressions 66
3.2 Exclusive-OR and Equivalence Operations 68
3.3 The Consensus Theorem 70
3.4 Algebraic Simplification of Switching Expressions 72
3.5 Proving Validity of an Equation 74
Programmed Exercises 77
Problems 82
Unit 4 Applications of Boolean Algebra
Minterm and Maxterm Expansions 87
Objectives 87
Study Guide 88
4.1 Conversion of English Sentences to Boolean Equations 94
4.2 Combinational Logic Design Using a Truth Table 96
4.3 Minterm and Maxterm Expansions 97
4.4 General Minterm and Maxterm Expansions 100
4.5 Incompletely Specified Functions 103
4.6 Examples of Truth Table Construction 104
4.7 Design of Binary Adders and Subtracters 108
Problems 114
Unit 5 Karnaugh Maps 123
Objectives 123
Study Guide 124
5.1 Minimum Forms of Switching Functions 134
5.2 Two- and Three-Variable Karnaugh Maps 136
5.3 Four-Variable Karnaugh Maps 141
5.4 Determination of Minimum Expressions Using
Essential Prime Implicants 144
5.5 Five-Variable Karnaugh Maps 149
5.6 Other Uses of Karnaugh Maps 152
5.7 Other Forms of Karnaugh Maps 153
Programmed Exercises 154
Problems 159
Unit 6 Quine-McCluskey Method 167
Objectives 167
Study Guide 168
6.1 Determination of Prime Implicants 173
6.2 The Prime Implicant Chart 176
6.3 Petrick’s Method 179
6.4 Simplification of Incompletely Specified Functions 181
6.5 Simplification Using Map-Entered Variables 182
6.6 Conclusion 184
Programmed Exercise 185
Problems 189
Unit 7 Multi-Level Gate Circuits
NAND and NOR Gates 193
Objectives 193
Study Guide 194
7.1 Multi-Level Gate Circuits 199
7.2 NAND and NOR Gates 204
7.3 Design of Two-Level NAND- and NOR-Gate Circuits 206
7.4 Design of Multi-Level NAND- and NOR-Gate Circuits 209
7.5 Circuit Conversion Using Alternative Gate Symbols 210
7.6 Design of Two-Level, Multiple-Output Circuits 214
Determination of Essential Prime Implicants for
Multiple-Output Realization 216
7.7 Multiple-Output NAND- and NOR-Gate Circuits 217
Problems 218
Unit 8 Combinational Circuit Design
and Simulation Using Gates 225
Objectives 225
Study Guide 226
8.1 Review of Combinational Circuit Design 229
8.2 Design of Circuits with Limited Gate Fan-In 230
8.3 Gate Delays and Timing Diagrams 232
8.4 Hazards in Combinational Logic 234
8.5 Simulation and Testing of Logic Circuits 240
Problems 243
Design Problems 246
Seven-Segment Indicator 246
Unit 9 Multiplexers, Decoders, and Programmable
Logic Devices 252
Objectives 252
Study Guide 253
9.1 Introduction 260
9.2 Multiplexers 261
9.3 Three-State Buffers 265
9.4 Decoders and Encoders 268
9.5 Read-Only Memories 271
9.6 Programmable Logic Devices 275
Programmable Logic Arrays 275
Programmable Array Logic 278
9.7 Complex Programmable Logic Devices 280
9.8 Field-Programmable Gate Arrays 282
Decomposition of Switching Functions 283
Problems 286
Unit 10 Introduction to VHDL 294
Objectives 294
Study Guide 295
10.1 VHDL Description of Combinational Circuits 299
10.2 VHDL Models for Multiplexers 304
10.3 VHDL Modules 306
Four-Bit Full Adder 308
Contents ix
10.4 Signals and Constants 311
10.5 Arrays 312
10.6 VHDL Operators 315
10.7 Packages and Libraries 316
10.8 IEEE Standard Logic 318
10.9 Compilation and Simulation of VHDL Code 321
Problems 322
Design Problems 327
Unit 11 Latches and Flip-Flops 331
Objectives 331
Study Guide 332
11.1 Introduction 336
11.2 Set-Reset Latch 338
11.3 Gated Latches 342
11.4 Edge-Triggered D Flip-Flop 346
11.5 S-R Flip-Flop 349
11.6 J-K Flip-Flop 350
11.7 T Flip-Flop 351
11.8 Flip-Flops with Additional Inputs 352
11.9 Asynchronous Sequential Circuits 354
11.10 Summary 357
Problems 358
Programmed Exercise 367
Unit 12 Registers and Counters 370
Objectives 370
Study Guide 371
12.1 Registers and Register Transfers 376
Parallel Adder with Accumulator 378
12.2 Shift Registers 380
12.3 Design of Binary Counters 384
12.4 Counters for Other Sequences 389
Counter Design Using D Flip-Flops 393
12.5 Counter Design Using S-R and J-K Flip-Flops 395
12.6 Derivation of Flip-Flop Input Equations—Summary 398
Problems 402
Unit 13 Analysis of Clocked Sequential Circuits 412
Objectives 412
Study Guide 413
13.1 A Sequential Parity Checker 419
13.2 Analysis by Signal Tracing and Timing Charts 421
13.3 State Tables and Graphs 425
Construction and Interpretation of Timing Charts 430
13.4 General Models for Sequential Circuits 432
Programmed Exercise 436
Problems 441
Unit 14 Derivation of State Graphs and Tables 453
Objectives 453
Study Guide 454
14.1 Design of a Sequence Detector 457
14.2 More Complex Design Problems 463
14.3 Guidelines for Construction of State Graphs 467
14.4 Serial Data Code Conversion 473
14.5 Alphanumeric State Graph Notation 476
14.6 Incompletely Specified State Tables 478
Programmed Exercises 480
Problems 486
Unit 15 Reduction of State Tables
State Assignment 497
Objectives 497
Study Guide 498
15.1 Elimination of Redundant States 505
15.2 Equivalent States 507
15.3 Determination of State Equivalence Using an
Implication Table 509
15.4 Equivalent Sequential Circuits 512
15.5 Reducing Incompletely Specified State Tables 514
15.6 Derivation of Flip-Flop Input Equations 517
15.7 Equivalent State Assignments 519
15.8 Guidelines for State Assignment 523
15.9 Using a One-Hot State Assignment 528
Problems 531
Unit 16 Sequential Circuit Design 545
Objectives 545
Study Guide 546
16.1 Summary of Design Procedure for Sequential Circuits 548
16.2 Design Example—Code Converter 549
16.3 Design of Iterative Circuits 553
Design of a Comparator 553
16.4 Design of Sequential Circuits Using ROMs and PLAs 556
16.5 Sequential Circuit Design Using CPLDs 559
16.6 Sequential Circuit Design Using FPGAs 563
16.7 Simulation and Testing of Sequential Circuits 565
16.8 Overview of Computer-Aided Design 570
Design Problems 572
Additional Problems 578
Unit 17 VHDL for Sequential Logic 585
Objectives 585
Study Guide 586
17.1 Modeling Flip-Flops Using VHDL Processes 590
17.2 Modeling Registers and Counters
Using VHDL Processes 594
17.3 Modeling Combinational Logic Using VHDL Processes 599
17.4 Modeling a Sequential Machine 601
17.5 Synthesis of VHDL Code 608
17.6 More About Processes and Sequential Statements 611
Problems 613
Simulation Problems 624
Unit 18 Circuits for Arithmetic Operations 626
Objectives 626
Study Guide 627
18.1 Serial Adder with Accumulator 629
18.2 Design of a Binary Multiplier 633
18.3 Design of a Binary Divider 637
Programmed Exercises 644
Problems 648
Unit 19 State Machine Design with SM Charts 660
Objectives 660
Study Guide 661
19.1 State Machine Charts 662
19.2 Derivation of SM Charts 667
19.3 Realization of SM Charts 672
Problems 677
Unit 20 VHDL for Digital System Design 684
Objectives 684
Study Guide 685
20.1 VHDL Code for a Serial Adder 688
20.2 VHDL Code for a Binary Multiplier 690
20.3 VHDL Code for a Binary Divider 700
20.4 VHDL Code for a Dice Game Simulator 702
20.5 Concluding Remarks 705
Problems 706
Lab Design Problems 709
A Appendices 713
A MOS and CMOS Logic 713
B VHDL Language Summary 719
C Tips for Writing Synthesizable VHDL Code 724
D Proofs of Theorems 727
E Answers to Selected Study Guide Questions and Problems 729
References 785
Index 786
Description of the CD 792
->**********************************04_Morris_en.txt
1. Preface ix
1. 1 Digital Systems and Binary Numbers 1
1. 1.1 Digital Systems 1
2. 1.2 Binary Numbers 4
3. 1.3 Number-Base Conversions 6
4. 1.4 Octal and Hexadecimal Numbers 9
5. 1.5 Complements of Numbers 11
6. 1.6 Signed Binary Numbers 17
7. 1.7 Binary Codes 22
8. 1.8 Binary Storage and Registers 31
9. 1.9 Binary Logic 34
2. 2 Boolean Algebra and Logic Gates 41
1. 2.1 Introduction 42
2. 2.2 Basic Definitions 42
3. 2.3 Axiomatic Definition of Boolean Algebra 43
4. 2.4 Basic Theorems and Properties of Boolean Algebra 47
5. 2.5 Boolean Functions 50
6. 2.6 Canonical and Standard Forms 56
7. 2.7 Other Logic Operations 65
8
8. 2.8 Digital Logic Gates 67
9. 2.9 Integrated Circuits 73
3. 3 Gate-Level Minimization 82
1. 3.1 Introduction 83
2. 3.2 The Map Method 83
3. 3.3 Four-Variable K-Map 90
4. 3.4 Product-of-Sums Simplification 95
5. 3.5 Don’t-Care Conditions 99
6. 3.6 NAND and NOR Implementation 102
7. 3.7 Other Two-Level Implementations 110
8. 3.8 Exclusive-OR Function 115
9. 3.9 Hardware Description Languages (HDLS) 121
10. 3.10 Truth Tables in HDLS 138
4. 4 Combinational Logic 147
1. 4.1 Introduction 148
2. 4.2 Combinational Circuits 148
3. 4.3 Analysis of Combinational Circuits 149
4. 4.4 Design Procedure 153
5. 4.5 Binary Adder–Subtractor 156
6. 4.6 Decimal Adder 168
7. 4.7 Binary Multiplier 170
8. 4.8 Magnitude Comparator 172
9
9. 4.9 Decoders 175
10. 4.10 Encoders 179
11. 4.11 Multiplexers 182
12. 4.12 HDL Models of Combinational Circuits 189
13. 4.13 Behavioral Modeling 215
14. 4.14 Writing a Simple Testbench 223
15. 4.15 Logic Simulation 229
5. 5 Synchronous Sequential Logic 245
1. 5.1 Introduction 246
2. 5.2 Sequential Circuits 246
3. 5.3 Storage Elements: Latches 248
4. 5.4 Storage Elements: Flip-Flops 253
5. 5.5 Analysis of Clocked Sequential Circuits 261
6. 5.6 Synthesizable HDL Models of Sequential Circuits 275
7. 5.7 State Reduction and Assignment 300
8. 5.8 Design Procedure 305
6. 6 Registers and Counters 326
1. 6.1 Registers 326
2. 6.2 Shift Registers 330
3. 6.3 Ripple Counters 338
4. 6.4 Synchronous Counters 343
5. 6.5 Other Counters 351
10
6. 6.6 HDL Models of Registers and Counters 356
7. 7 Memory and Programmable Logic 377
1. 7.1 Introduction 378
2. 7.2 Random-Access Memory 379
3. 7.3 Memory Decoding 386
4. 7.4 Error Detection and Correction 391
5. 7.5 Read-Only Memory 394
6. 7.6 Programmable Logic Array 400
7. 7.7 Programmable Array Logic 404
8. 7.8 Sequential Programmable Devices 408
8. 8 Design at the Register Transfer Level 429
1. 8.1 Introduction 430
2. 8.2 Register Transfer Level (RTL) Notation 430
3. 8.3 RTL Descriptions 432
4. 8.4 Algorithmic State Machines (ASMs) 450
5. 8.5 Design Example (ASMD CHART) 459
6. 8.6 HDL Description of Design Example 469
7. 8.7 Sequential Binary Multiplier 487
8. 8.8 Control Logic 492
9. 8.9 HDL Description of Binary Multiplier 498
10. 8.10 Design with Multiplexers 513
11. 8.11 Race-Free Design (Software Race Conditions) 529
11
12. 8.12 Latch-Free Design (Why Waste Silicon?) 532
13. 8.13 SystemVerilog—An Introduction 533
9. 9 Laboratory Experiments with Standard ICs and FPGAs 555
1. 9.1 Introduction to Experiments 555
2. 9.2 Experiment 1: Binary and Decimal Numbers 560
3. 9.3 Experiment 2: Digital Logic Gates 563
4. 9.4 Experiment 3: Simplification of Boolean Functions 565
5. 9.5 Experiment 4: Combinational Circuits 567
6. 9.6 Experiment 5: Code Converters 568
7. 9.7 Experiment 6: Design with Multiplexers 570
8. 9.8 Experiment 7: Adders and Subtractors 572
9. 9.9 Experiment 8: Flip-Flops 575
10. 9.10 Experiment 9: Sequential Circuits 577
11. 9.11 Experiment 10: Counters 579
12. 9.12 Experiment 11: Shift Registers 580
13. 9.13 Experiment 12: Serial Addition 584
14. 9.14 Experiment 13: Memory Unit 585
15. 9.15 Experiment 14: Lamp Handball 587
16. 9.16 Experiment 15: Clock-Pulse Generator 591
17. 9.17 Experiment 16: Parallel Adder and Accumulator 593
18. 9.18 Experiment 17: Binary Multiplier 595
19. 9.19 HDL Simulation Experiments and Rapid Prototyping with
12
FPGAs 599
10. 10 Standard Graphic Symbols 605
1. 10.1 Rectangular-Shape Symbols 605
2. 10.2 Qualifying Symbols 608
3. 10.3 Dependency Notation 610
4. 10.4 Symbols for Combinational Elements 612
5. 10.5 Symbols for Flip-Flops 614
6. 10.6 Symbols for Registers 616
7. 10.7 Symbols for Counters 619
8. 10.8 Symbol for RAM 621
1. Appendix 624
2. Answers to Selected Problems 638
3. Index 683
->**********************************05_Matin_en.txt
CHAPTER 1
Algebra of logical variables 1
11 Logical variable 2
12 Boolean Algebra 4
13 Basic Theorems of Boolean Algebra 5
14 Boolean functions 7
15 Logic functions used in digital electronics 9
151 AND function (•) 10
152 OR (+) 10 function
153 Inversion function or NOT (ɡ) 11
154 NAND function 11
155 NOR function 12
156 Exclusive OR function
157 Exclusive NOR (XNOR) function 14
16 Combinational Circuits 15
17 Simplification of logical functions 16
171 Algebraic simplification 17
172 Karnaugh Tables 17
18 Incomplete functions 20
Exercises 21
CHAPTER 2
Number systems and binary arithmetic 23
21 Number systems 24
22 Binary system 24
23 Hexadecimal and octal system 26
24 Binary numerical codes 29
25 Alphanumeric codes 30
X DIGITAL ELECTRONICS
26 Error detector codes 33
27 Error correcting codes 34
28 Arithmetic operations with binary numbers 35
281 Binary sum 36
282 Binary subtraction 37
283 Representation of negative numbers 38
284 Binary multiplication and division 40
29 Arithmetic operations with other codes 42
291 Sum BCD 43
292 Subtraction BCD 43
293 Multiplication and division BCD 45
294 Hexadecimal addition 46
295 Hexadecimal subtraction 47
Exercises 49
CHAPTER 3
Arithmetic Combinational Circuits 53
31 Design of combinational circuits 54
32 Binary adder 54
321 Half-Adder 54
322 Full-Adder 56
323 Integrated full adder circuit 59
33 Parallel adder 60
331 Parallel adder with serial carry 60
332 Parallel adder with parallel carry 61
333 Parallel adder with parallel carry applied to groups 65
334 Integrated adding circuits 66
34 BCD Adder 71
35 Binary subtractor 74
351 Complete subtractor 74
352 Multi-bit Binary Subtractor 77
353 Integrated Subtraction Circuits 79
36 Adder/subtractor 80
37 Arithmetic Logic Unit 81
371 Integrated arithmetic-logical units 84
38 Advance drive unit 86
Exercises 88
CHAPTER 4
Combinational Logic Circuits 91
41 Parity generator/detector 92
411 Parity bit 92
412 Parity generator/detector circuit: 74ls280 94
42 Binary Comparators of Magnitude 95
421 Integrated comparators: 74ls85 96
CONTENT XI
43 Multiplexer 99
431 Multiplexer Integrated Circuits 102
432 Multiplexer Extension 103
433 Using the multiplexer for function generation 104
44 Encoders 107
441 Priority Encoders 109
442 Integrated priority encoders 111
443 Expansion of priority encoders 112
45 Decoders 114
451 The decoder as a data demultiplexer 115
452 Decoder/demultiplexer ICs 116
453 Expansion of the decoder/demultiplexer 117
454 Multiplexer-demultiplexer set for data transfer 118
455 The decoder as a generator of logical functions 119
46 120 Code Converters
461 BCD to 7 segment converter 121
462 BCD to Binary and Binary to BCD 122 Converter
47 Data bus 123
471 Tristate output 124
472 Tristate buffer 124
473 Transceivers 125
Exercises 127
CHAPTER 5
Digital Integrated Circuits 129
51 Classification of integrated circuits 130
511 Depending on the type of signals they handle 130
512 According to internal construction 130
513 Depending on substrate material 131
514 According to the number of transistors 132
515 Depending on the resolution used in device design 132
516 According to the design methodology 134
517 Depending on the type of active devices used 136
518 Depending on the way digital doors are constructed 137
52 Nomenclature of integrated circuits 139
521 Encapsulated 142
53 Electrical characteristics 143
531 Supply voltage 144
532 Logic input and output voltages 145
533 Noise margin 146
534 Input and output currents 147
535 Switching times 149
536 Power dissipated 150
54 Special Considerations 151
541 Static electricity 151
542 Power supply decoupling 151
543 Latch-up phenomenon 152
XII DIGITAL ELECTRONICS
55 Special digital inputs and outputs 154
551 Buffer 154
552 Schmitt trigger or schmitt trigger 154
553 Open-collector output 155
56 Connecting digital circuits 156
561 Pull-up and pull-down resistors 156
562 Connection of different logical families 157
563 Connection of circuits at different supply voltages 158
Exercises 161
CHAPTER 6
Sequential circuits 165
621 RS 166 Scale
611 RS scale with NOR 166 doors
612 RS scale with NAND gates 169
613 Integrated circuits and applications 170
62 Synchronous flip-flop 173
621 RS synchronous flip-flop 173
622 Synchronous RS flip-flop with asynchronous inputs 175
623 Flip-flop RS master-slave 177
63 Other flip-flops 179
631 D flip-flop triggered by level 179
632 Edge-triggered D flip-flop 180
633 The D flip-flop in integrated circuits 183
634 The T 184 flip-flop
635 The JK 185 flip-flop
635 The JK flip-flop in integrated circuits 189
64 Characteristic parameters of flip-flops 190
65 Sequential Circuits 191
651 Types of sequential circuits 192
652 Types of synchronous sequential circuits 194
66 Synthesis of synchronous sequential circuits 195
67 Analysis of synchronous sequential circuits 205
68 Other design methods 208
69 Design of complex systems 210
610 General Design Considerations 217
Exercises 219
CHAPTER 7
Registers and counters 225
71 Records 226
711 Storage records 226
712 Shift registers 228
72 Counters 232
721 Binary asynchronous counter 233
722 Decimal asynchronous counter 234
723 Binary synchronous counter 236
724 Decimal synchronous counter 238
CONTENTS XIII
725 Reversible synchronous counter 242
726 Counters with anti-blocking protection 246
727 Shift Register-Based Synchronous Counters 247
728 Integrated digital counters 249
729 Expansion of meters 250
7210 Register and counter applications 251
Exercises 255
CHAPTER 8
User Programmable Logic 257
81 Programmable logic circuits 258
82 Advantages and disadvantages of programmable logic circuits 259
821 Design with standard circuits vs. design with circuits
programmable logic 259
822 Design with Application Specific Circuits (ASIC) front
to design with programmable circuits 261
83 PLD 264 type programmable logic circuits
831 PROM structure 264
832 PLA Structure 265
833 PAL structure 266
834 Input/output structure 267
835 Structure of the current PLDs 270
84 FPGA type programmable logic circuits 271
85 PLD-FPGA Comparison 274
86 Design techniques with programmable logic circuits 276
861 Logical design 277
862 Compilation 277
863 Simulation 277
864 Programming 278
87 Conclusions 278
Exercises 279
CHAPTER 9
Memories 281
91 Random access memories (RAM) 282
911 General characteristics 282
912 Read/write memories 283
913 Read-only memories (ROM) 295
914 Non-volatile RAM memories (NVRAM) 298
915 Memory grouping 299
92 Sequential access memories 301
921 FIFOs 301
922 LIFOs 302
93 Applications 303
931 LUTs (Look Up Tables) 303
932 Systems Synchronization 303
Exercises 305
XIV DIGITAL ELECTRONICS
CHAPTER 10
Analog-digital, digital-analog converters 307
101 Nyquist's theorem 308
102 Digital-to-analog converter (DAC) 308
1021 D/A converter with weighted resistors 309
1022 D/A converter with r-2r network on 310 ladder
1023 Inverted ladder d/a converter 311
1024 Parameters of d/a converters 312
103 Analog-digital converter 315
1031 A/D converter with comparators 317
1032 Successive approximation a/d converter 318
1033 A/D converter with counters 319
1034 Dual ramp a/d converter 321
1035 Ramp Width A/D Converter 322
1036 A/D converter 323
1037 Parameters of a/d converters 324
Exercises 328
Answers to exercises 329
Chapter 1 331
Chapter 2 340
Chapter 3 345
Chapter 4 349
Chapter 5 356
Chapter 6 359
Chapter 7 373
Chapter 8 378
Chapter 9 379
Chapter 10 381
Bibliography 383
Analytical index 385

->**********************************06_Adan_en.txt
SHORT QUESTIONS 88
CHAPTER 4 COMBINATIONAL SYSTEMS: MODULES93
CONTENTS 93
SOLVED EXERCISES 94
TEST AND SHORT QUESTIONS 178
CHAPTER 5 ARITHMETIC AND LOGICAL CIRCUITS 189
CONTENTS 189
SOLVED EXERCISES 190
TEST AND SHORT QUESTIONS 227
6 DIGITAL CIRCUITS SOLVED PROBLEMS AND EXERCISES © RA-MA
CHAPTER 6 SEQUENTIAL SYSTEMS: FLIP-UPS 231
CONTENTS 231
SOLVED EXERCISES 232
TEST AND SHORT QUESTIONS 291
CHAPTER 7 SEQUENTIAL SYSTEMS: MODULES 305
CONTENTS 305
SOLVED EXERCISES 306
TEST AND SHORT QUESTIONS 405
CHAPTER 8 SOLUTIONS TO TEST AND SHORT QUESTIONS 413

->**********************************07_Barajas_en.txt
INDEX
INTRODUCTION 11

CHAPTER 1

INTRODUCTION TO DIGITAL SYSTEMS13
11 ANALOG AND DIGITAL SYSTEMS13
12 BINARY SYSTEMS 15
13 COMBINATIONAL AND SEQUENTIAL SYSTEMS17
14 REPRESENTATION OF INFORMATION IN BINARY SYSTEMS18
141 Numbering systems18
15 THE BINARY SYSTEM 19
151 Conversion between binary and decimal systems 20
152 Octal and hexadecimal systems22
153 Binary codes24

CHAPTER 2

BOOLE ALGEBRA AND LOGICAL GATES37
21 POSTULATES AND FUNDAMENTAL PROPERTIES OF THE ALGEBRA OF
BOOLE 37
22 BOOLEAN FUNCTIONS AND EXPRESSIONS39
221 Truth tables Logical functions39
222 Representation in canonical form of a Boolean function40
223 Simplification of logical functions44
224 Transition from non-canonical to canonical forms 51
225 Logical functions with incomplete forms51
226 Implementation of functions with logic gates53
227 Multiple functions 57

CHAPTER 3

COMBINATIONAL SYSTEMS61
31 ANALYSIS OF COMBINATIONAL CIRCUITS62
32 SYNTHESIS OF COMBINATIONAL CIRCUITS62
321 Implementation with AND, OR and NOT gates 63
322 Implementation with NAND gates, and NOR 64
33 ENCODERS 66
331 Encoder with priority 68
34 DECODERS 69
341 Implementation of logical functions with decoders72
342 Expansion of decoders74
35 MULTIPLEXERS75
36 DEMULTIPLEXERS 76
361 Implementation of Logic Functions with Multiplexers 77

CHAPTER 4

ARITHMETIC CIRCUITS81
41 MAGNITUDE COMPARATOR 81
42 ADDER 84
421 Half-adder84
422 Total Adder 84
423 n-bit adder circuit 86
424 Series and parallel carry87
43 NEGATIVE NUMBERS 88
431 Addition of negative numbers91
432 Adder/subtractor 92
44 MULTIPLIER93

CHAPTER 5

FLIP-UPS AND SYNCHRONOUS DESIGN97
51 FLIP-OFFS97
511 Types of flip-flops 99
52 SYNCHRONOUS FLIP-LOPS 103
521 active SR per level 103
53 SYNCHRONISM PER FLANGE 106
531 Master-slave structure 107
532 Significant switching times108
533 Synchronous flip-flops with asynchronous inputs112
534 Types of synchronous flip-flops114
54 SCHEDULES 124

CHAPTER 6

RECORDS AND ACCOUNTANTS 129
61 RECORDS129
611 Series-parallel registers130
612 Tristate output 133
613 Parallel registers134
62 COUNTERS135
621 Asynchronous counters 135
622 Synchronous counters 138
623 Initialization 141
624 Counters based on shift registers143

CHAPTER 7

SEQUENTIAL CIRCUITS149
71 SYNTHESIS OF A SEQUENTIAL CIRCUIT 149
711 State machines 149
72 ANALYSIS OF A SEQUENTIAL CIRCUIT 167
CHAPTER 8 MEMORIES169
81 RAM AND ROM MEMORY 172
811 Structure of the reports 173
82 MEMORY EXTENSION181
83 SYNTHESIS OF LOGICAL FUNCTIONS WITH MEMORIES 188

CHAPTER 9
PROGRAMMABLE LOGIC 191
91 PROGRAMMING PLANS 192
92 PLD (PROGRAMMABLE LOGIC DEVICES)193
93 COMMERCIAL FPGA’S 200

CHAPTER 10

DIGITAL TECHNOLOGIES203
101 THE UNION PN203
102 THE DIODE205
103 THE BIPOLAR TRANSISTOR 206
104 TTL LOGIC 210
105 THE MOS212 TRANSISTOR
106 NMOS 215 LOGIC GATES
107 CMOS LOGIC GATES 217
ALPHABETICAL INDEX221

->**********************************08_Velasquez_en.txt
Presentation
PART 1. Logical families
TTL logic gates
Introduction
Structure of a two-input TTL NAND gate
Output loadability of a TTL inverting gate
Analytical estimation
Analysis using PSpice
Transfer Features
Standard TTL inverting gate
Reversing door (CI 7404)
NAND gate (IC 7400)
Floating inputs on TTL gates
The potential risk of floating entries
What to do with unused tickets?
Temporal characterization
Characteristic parameters
The ring oscillator
Components
Experimental verification
Obtaining truth tables
NOT logic function (inversion)
NAND logic function
NOR logic function
Output loadability
Estimation of the output resistance of a device
Transfer characteristics of an inverter
Transfer characteristic vs(ve)
Transfer characteristic ie(ve)
Floating inputs on a NAND gate (74x00 IC)
Temporal characterization: ring oscillator
Exercises and reinforcement questions
CMOS logic gates
Introduction
Structure of a two-input CMOS NAND gate
Output loadability of a CMOS NAND gate
Preliminary considerations
Analysis using PSpice

Case study 1
Case study 2
Case study 3
CI 4011B Loadability
Transfer Features
Floating inputs on CMOS gates
Components
Experimental verification
Output loadability
Transfer characteristics of a CMOS inverter
Transfer characteristic vs(ve)
Transfer characteristic ie(ve)
Floating inputs in a NAND gate (CI 4011B)
Exercises and reinforcement questions
PART 2. Combinational logic
Basic 2 to 4 Binary Decoder
Introduction
Basic 2 to 4 Binary Decoder
Decoding with outputs active at high level
Decoding with outputs active at low level
Simulation
Decoding with outputs active at high level
Decoding with outputs active at low level
Components
Experimental verification
Decoding with outputs active at high level
Decoding with outputs active at low level
Exercises and reinforcement questions
Optimal synthesis of combinational circuits
Introduction
Synthesis in the form of sum of products (AND-OR)
Synthesis in the form of a product of sums (OR-AND)
NAND-NAND two-level synthesis
Two-level NOR-NOR synthesis
Multilevel synthesis with two-input NAND gates
Transient analysis: random phenomena
Types of random phenomena
Random function phenomena
Elimination of random phenomena
Simulation
Analysis in steady state
Transient analysis
Components
Experimental verification
Exercises and reinforcement questions
Basic 4 to 2 Binary Encoder
Introduction
Basic 4 to 2 binary encoder without priority
Encoding with active inputs at high level
Encoding with active low level inputs
Basic 4 to 2 Binary Encoder with Priority
Encoding with active inputs at high level
Encoding with active low level inputs
Simulation
4 to 2 encoder circuits without priority
Encoding with active inputs at high level
Encoding with active low level inputs
4 to 2 priority encoder circuits
Encoding with active inputs at high level
Encoding with active low level inputs
Components
Experimental verification
Non-priority coding and active inputs at low level
Encoding with priority and active inputs at low level
Exercises and reinforcement questions
Comparator, parity and code converter circuits
Introduction
Comparator arithmetic circuits
Generator circuit and parity detector circuit
Code converter circuits
Simulation
Comparator circuit
Parity generator circuit
Code converter circuits
Components
Experimental verification
Comparator circuit
Parity generator circuit
Code converter circuits
Exercises and reinforcement questions
2 to 4 binary decoder with polarity control
Introduction
Basic 2 to 4 Binary Decoder with Polarity Control
Three different syntheses with two-input NAND gates
Synthesis with NAND gates of any number of inputs
XOR gate-based synthesis
Simulation
Components
Experimental verification
Exercises and reinforcement questions
Prime number detection with multiplexers
Introduction
Design of a BCD prime number detector
Synthesis using logic gates
Synthesis using a 16:1 multiplexer
Synthesis using an 8:1 multiplexer
Alternative synthesis using an 8:1 multiplexer
Design of a 4-bit prime number detector
Synthesis using logic gates
Synthesis using a 16:1 multiplexer
Synthesis using two 8:1 multiplexers
Alternative synthesis using an 8:1 multiplexer
Simulation
BCD prime number detectors with multiplexer
Synthesis using a 16:1 multiplexer
Synthesis using an 8:1 multiplexer
Alternative synthesis using an 8:1 multiplexer
4-bit prime number detectors with multiplexer
Synthesis using a 16:1 multiplexer
Synthesis using two 8:1 multiplexers
Alternative synthesis using an 8:1 multiplexer
Components
Experimental verification
Exercises and reinforcement questions
Full adder and parallel binary adder
Introduction
Semi-adding circuit
Full adder circuit
Full adder implementations
Two-level AND-OR synthesis using PAL
NAND-NAND two-level synthesis
Two six-level syntheses with basic doors
Four-level synthesis with three-input NAND gates
Two-level synthesis based on XOR and NAND gates
Three-level synthesis based on XOR and NAND gates
Parallel binary adder with serial carry
Simulation
Semi-adder
Full adder
4-bit parallel binary adder with serial carry
Carry propagation and associated delay
Components
Experimental verification
Semi-adder
Full adder
2-bit parallel binary adder with serial carry
Exercises and reinforcement questions
4-bit two's complement arithmetic unit
Introduction
Design of a 4-bit arithmetic unit in C2
The 74x283 adder
The XOR gate as a solution to implement subtraction
The overflow detector
Complete arithmetic unit
Simulation
Adder module
Adder/subtractor module
Arithmetic unit with overflow detector
Components
Experimental verification
Adder module
Adder/subtractor module
Arithmetic unit with overflow detector
Exercises and reinforcement questions
PART 3. Synchronous sequential logic
Clock signal generation with astable circuits
Introduction
Design of an astable multivibrator with logic gates
Design of an astable multivibrator with the 555
Simulation
Components
Experimental verification
Exercises and reinforcement questions
Module 8 curl counter with T flip-flops
Introduction
Two implementations of a ripple counter
Module 8 counter designed with J – K flip-flops
Module 8 counter designed with D flip-flops
The problem of spurious states
Simulation
Response of the counter designed with J – K flip-flops
Filtering spurious states using logging
Response of the counter designed with D flip-flops
Filtering spurious states using logging
Components
Experimental verification
Exercises and reinforcement questions
Module 8 curl counter with 74x90
Introduction
Design of a module 8 counter with the 74x90
The problem of spurious states
Simulation
Module 8 counter state sequence
Filtering spurious states using logging
Decoding states with 7448
Components
Experimental verification
Exercises and reinforcement questions
Module 4 reversible synchronous counter with J – K flip-flops
Introduction
Design of a module 4 reversible synchronous counter
Simulation
Design implementation with CI 7473
Constant S control input
S logic level change with clock signal low
S logic level change with clock signal high
Conclusions
Design implementation with the 74LS73A IC
Components
Experimental verification
Exercises and reinforcement questions
Synchronous counters with the 74x163
Introduction
Counter design with the 74x163
Counter in free run mode (module 16)
Module 13 counter with the sequence 0,1,…,12
Module 12 counter with the sequence 3,4,…,14
Counter module 146 with the sequence 0,1,…,145
Simulation
Counter in free run mode (module 16)
Module 13 counter with the sequence 0,1,…,12
Module 12 counter with the sequence 3,4,…,14
Counter module 146 with the sequence 0,1,…,145
Components
Experimental verification
Exercises and reinforcement questions
Digital second hand with modular counters
Introduction
Three designs of a seconds hand with synchronous counters
Combination of two 74x163
Combination of a 74x162 and a 74x163
Combination of a 74x162 and a 74x161
Simulation
Components
Experimental verification
Module 10 counter (second hand units)
Module 6 counter (tens of the second hand)
Full digital seconds hand
Exercises and reinforcement questions
Decoding the states of a counter
Introduction
Decoding modular counters
Decoding an asynchronous counter
Decoding a synchronous counter
Risk of interference on decoded lines
Eliminating the risk of decoding interference
Outdated decoder enable
Filtering by registry
Direct decoding with a ring counter
Simulation
Decoding 74x90 counters with 74x138 devices
Decoding 74x163 counters with 74x42 devices
Eliminating the risk of decoding interference
Outdated decoder enable
Filtering by registry
Components
Experimental verification
Exercises and reinforcement questions
4-bit shift register with D flip-flops
Introduction
Design of a 4-bit shift register
Simulation
Serial input and parallel output
Parallel input and parallel output
Components
Experimental verification
Exercises and reinforcement questions
Pseudorandom number generator
Introduction
3-bit pseudorandom generator
4-bit pseudorandom generator
Simulation
3-bit pseudorandom generator
4-bit pseudorandom generator
Components
Experimental verification
3-bit pseudorandom generator
4-bit pseudorandom generator
Exercises and reinforcement questions
Layouts with 74x194 shift register
Introduction
Sequential design based on the 74x194
Charging and inhibition
The ring counter
Accountant Johnson
serial communication
Simulation
Charging and inhibition
ring counter
serial communication
Accountant Johnson
serial communication
Components
Experimental verification
Charging and inhibition
Ring counter and serial communication
Johnson counter and serial communication
Exercises and reinforcement questions
Mealy and Moore finite state automata
Introduction
Sequential design according to the Mealy and Moore models
Specifications
Design according to the Mealy model
Design according to the Moore model
Simulation
Mealy finite state automaton
Moore's finite state automaton
Components
Experimental verification
Exercises and reinforcement questions
PART 4. Asynchronous sequential logic
Asynchronous flip-flops
Introduction
Three types of asynchronous flip-flops
Asynchronous flip-flop without inputs
Asynchronous bistable S – R
Asynchronous bistable –
Simulation
Asynchronous bistable S – R
Response to allowed input sequences
Response to illegal input sequences
Determination of the minimum pulse width
Asynchronous bistable –
Response to allowed input sequences
Components
Experimental verification
Asynchronous flip-flop without inputs
Asynchronous bistable S – R
Asynchronous bistable –
Exercises and reinforcement questions
Debounce circuits with asynchronous flip-flops
Introduction
The problem of bounces in digital design
The asynchronous flip-flop as a debounce circuit
NOR debounce circuit
NAND debounce circuit
NOT debounce circuit
Parking access detection
Simulation
Operation of NAND debounce circuit
Operation of the NOT debounce circuit
Components
Experimental verification
NAND debounce circuit
NOT debounce circuit
Exercises and reinforcement questions
Digital combination lock
Introduction
Design of a pulse mode sequence detector
Specifications
Design according to the Mealy model
Simulation
Components
Experimental verification
Operation in the absence of debounce circuits
Using a basic flip-flop as a debounce circuit
Using a flip-flop – as a debounce circuit
Exercises and reinforcement questions
Asynchronous frequency divider
Introduction
Design of a two-fold asynchronous frequency divider
Specifications
Design according to the Moore model
Simulation
Design with S – R asynchronous flip-flops
Failed preliminary design based on direct feedback
Correct design based on direct feedback
Components
Experimental verification
Design with S – R asynchronous flip-flops
Failed preliminary design based on direct feedback
Correct design based on direct feedback
Exercises and reinforcement questions
PART 5. Applications of commonly used logic functions
Decoding applications
Generation of minterms
Decoding address lines
Memory circuits and their storage capacity
Decoding memory addresses in a computer
Decoding from BCD to seven segment code
Decoding the states of a counter
Coding applications
Prioritized management of interruptions in a processor
Coding a numeric keypad
Analog-digital conversion: the flash converter
Digital video encoding in analog format
Error detection with parity circuits
Transmission errors and their detection
Parallel transmission with parity bits
Serial transmission with parity bits
Vertical redundancy check
Horizontal redundancy check
Two-dimensional redundancy check
Other error detection techniques
Arithmetic applications of comparators and adders
Arithmetic selector with external control signal
The full adder in multiplier circuits
The matrix multiplier
The multiplier with reserved carry
Other multiplier circuits
The ALU as a generalization of the modular adder
Three ALU circuits and their features
The ALU in computers
Counter Applications
Pulse counter in automated systems
frequency divider
digital clock
The digital timer
Digital waveform synthesizer
Frequency meter
The register-counter in computers
The computer and its internal structure
The program counter
The stack pointer
Microprogram register-counter
Registering data count on DMA controllers
The CX register-counter of the x86 architecture
Applications of shift registers
Interface logic in digital data transmission
The role of shift register in speech coding
Voice and data traffic in the analog subscriber loop
Revolution in the subscriber loop: fiber optics arrives
Synchronous serial transmission
Asynchronous serial transmission
Bit shifts and rotations
The basic combinational shifter
Circular shifters
Moving instructions in assembler
Setting a delay on bit streams
Generation of pseudorandom sequences
Detection of defects in logic circuits
Sources of white noise
Multiplexing applications
Generation of logical functions
Multiplexing of analog inputs in microcontrollers
Multiplexed scanning of dynamic displays
Multiplexed sweep with fixed function logic devices
Multiplexed scanning implemented on a microcontroller
Multiplexed scanning with configurable digital circuitry
Multiplexing in the Switched Telephone Network
Two-channel PCM-TDM transmission system
T-1 Digital Carrier System
Multi-level hierarchy in the RTC
Multiplexing and demultiplexing in optical access networks
A new paradigm of communications networks and services
PART 6. Introduction to prototyping embedded systems
Strategies to implement a digital circuit
Normalized Fixed Function Logic and Its Limitations
Custom logic design and its scope
Semi-custom logic design overview
Normalized cells, compiled cells, and macromodules
Intellectual Property (IP) Cores
Array-based implementation
Door matrices
Preconnected arrays
Microcontrollers: fundamentals and prototyping platforms
Structure and programming of microcontrollers
The microcontroller and its internal resources
Organization of memory access
The instruction set: CISC and RISC architectures
From source code to machine code
The microcontroller in embedded systems
Microchip PIC Microcontrollers
Electronic programming modules
PICkitTM 1 Flash Starter Kit
Curiosity High Pin Count (HPC)
PIC18F47Q10 Curiosity Nano
MPLAB Xpress General Purpose
Microcontrollers in the Arduino ecosystem
Arduino Diecimila and Arduino Duemilanove
Arduino UNO (versions R1, R2 and R3)
Expansion modules: shields
Arduino Mega 2560
Arduino Due and the jump to 32 bits
Arduino Nano 33 IoT
Arduino UNO R4
Texas Instruments MSP430 and C2000 Microcontrollers
MSP-EX430G2 Launchpad
C2000TM DIMM100 Experimenter's Kit
STM32 Microcontrollers from STMicroelectronics
blue pill
The STM32 Discovery family of prototyping platforms
STM32VLDISCOVERY
STM32F4DISCOVERY
B-U585I-IOT02A Discovery kit
The STM32 Nucleo family of prototyping platforms
Representative platforms of the STM32 Nucleo-64 series
Representative platforms of the STM32 Nucleo-144 series
Future prospects for microcontrollers
FPGA circuits: fundamentals and prototyping platforms
Internal structure of FPGA circuits
Multilevel architectures in configurable logic
Logic modules embedded in an FPGA circuit
The challenge of synchronism
Organization of configurable logical blocks
HDL languages for circuit simulation and synthesis
Xilinx Spartan-3E and Artix-7 family FPGA circuits
Altera Cyclone IV Family FPGA Circuits
An application in the field of industrial electronics
FPGA Circuits vs.microcontrollers
Appendices
The teaching laboratory
Introduction
The prototyping board
The power supply
Performance and handling
Wiring the source with a generic load
Prototyping board power
Power supply decoupling
The multimeter
The oscilloscope
The HM303-6 Analog Oscilloscope from HAMEG Instruments
The MP720009 digital oscilloscope from Multicomp PRO
Oscilloscope measurement probes
The DIgilent Analog Discovery 2 USB Oscilloscope
The integrated circuit tester
Notes on experimental setups
Instrumentation and its use
Practical tips
Auxiliary components
Common mistakes
Electrical hazards
Introduction
The ground connection
Severity of an electrocution
Identification of pins on integrated circuits
Pin numbering on an IC
Pin identification on logic gates
Pin Identification on Other Integrated Devices
Identification of terminals in optoelectronic components
Terminals of an LED and an LED light bar
Terminals of a seven-segment display
Identification of terminals on electrical components
Terminals of a rotary potentiometer
Terminals of an electrolytic capacitor
Terminals of a SPDT Rocker Toggle Switch
Terminals of a Slide Actuator SPDT Switch
Standard values of resistors and capacitors
Color code for resistors
Standard resistance values
Standard Capacitor Values
Simulation notes
Introduction
PSpice Quick Guide
Creating a project
Drawing a circuit in the schematic window
Simulation and execution profile
The PSpice Model Editor
Connecting a bus to a circuit
Linking a stimulus to a bus
Flip-flop initialization
Location of components in libraries
List of all components used
Sources of tension and digital stimuli
Discrete Semiconductors
Integrated devices with simulation model
Integrated devices without simulation model
Other components
Notes on commutation algebra
Introduction
Postulates and theorems of commutation algebra
XOR and XNOR logic functions
Bibliography
Monographs
Research articles
Technical information from manufacturers
Fixed Function Integrated Circuits (General)
Logic gates
Decoders
Multiplexer
Parity generator
Adder
Arithmetic-logical units (ALU circuits)
Timer
Asynchronous flip-flops
Synchronous flip-flops
Accountants
Records
ROM and RAM memory circuits
Microprocessors
Microcontrollers
Microcontroller-based development boards
Configurable digital logic (CPLD and FPGA circuits)
Development boards based on FPGA circuits
Video encoders
A/D converter
Signal generators
Luminescent diodes (LEDs)
Seven segment displays
Quadruple half-bridge
Rocker Toggle Switch
Simulation tool for electronic design
Web links of interest
Acronyms
Supplementary material
Index

->**********************************09_Guapacha_en.txt
Introduction xii
How to use this book?xv
Explanatory note xv
For Professor xv
For the student xvi
Lesson 1 The most basic 1
What is Boolean algebra?1
What is vhdl hardware description language?1
Mathematical foundations 2
Logical constants 2
Logical variables 3
Signals (signal) 3
Operators 4
Lesson 2 Number Systems 5
decimal system 5
Binary system 6
Octal system 7
Hexadecimal system 8
Workshop 10
Lesson 3 Conversions 13
Converting from binary to octal 13
Octal to Binary 14 Conversion
Binary to Hexadecimal Conversion 14
Workshop 16

Digital Logic Fundamentals VIII with VHDL
Lesson 4 Organizing logical values 19
Truth tables 19
Boolean Algebra Functions 19
Representation of numbers with sign 20
Lesson 5 vhdl - fundamental components 21
Entity (entity) 22
Architecture (architecture) 22
Lesson 6 Sentences 25
Concurrent 25
Coditionals 26
Cycles 28
Lesson 7 Xilinx development software – ise 31
Creating a project in xilinx ise 32
Ise-design flow 36
Synthesize (synthesize) 36
Register Transfer Level (rtl) 36
Design implementation (implementation design) 37
Generation of the programming file - fpga 38
Simulation and verification (test bench) 38
Lesson 8 Logic Gates i 41
Lesson 9 Logic Gates ii 45
Workshop 50
Lesson 10 Logic Gates iii 51
Workshop 54
Lesson 11 Logic Gates iv 55
Lesson 12 Operators and hierarchy 59
Workshop 61
Lesson 13 Logic Functions and Circuits 63
Complete example 63
Workshop 67
Lesson 14 Simplifying functions i 69
Example of function 70
Original function 74
Simplified function 75
Original function logic circuit 75
Workshop 75

Lesson 15 Simplifying functions ii 77
Step 1 80
Step 2 81
Step 3 81
Step 4 81
Step 5 81
Step 6 81
Step 7 81
Original function 84
Simplified function 85
Workshop 86
Lesson 16 Simplifying functions iii 87
Workshop 92
Lesson 17 Morgan's Laws i 93
Workshop 97
Lesson 18 Morgan's Laws II 99
Workshop 105
Lesson 19 Karnaugh Maps 107
Workshop 115
Lesson 20 Decoder 117
Lesson 21 Encoder 121
Lesson 22 Multiplexers 125
Lesson 23 Demultiplexers 129
Lesson 24 Add 133
Lesson 25 Binary Comparators 137
Lesson 26 Clock system (clock) 141
Lesson 27 Flip-flop 145
Bibliography 155

->**********************************10_Julian_en.txt
Editor's Message IX
About the author XI
Preface XIX
1 Micromanufacturing and technology 1
11 Introduction 1
12 The manufacturing process 4
121 Lithograph 5
1211 The photolithographic process 6
1212 Removal 7
1213 Masks 8
122 Oxidation 9
1221 External factors 10
123 Introduction of dopants 12
1231 Diffusion 12
1232 Implantation of ions 14
124 Deposition 15
1241 Evaporation 16
1242 Sputtering 16
1243 Chemical vapor deposition 16
1244 E p ita x is 19
125 Simplified processes 19
1251 Manufacture of a resistor 19
1252 Manufacturing of an NMOS 20 transistor
13 Geometric design rules 22
14 Technological processes 26
141 P-w e l l process 26
142 Twin-tub process 27
143 Silicon on insulator (SOI) 28
144 Inclusion of bipolar transistors 30
XIV general index
145 3D Processes 34
15 F a l la s 34
151 Performance o y i e l d 36
152 Margins 36
2 Devices 39
21 Interconnections 39
211 Parasitic capabilities 40
212 Parasitic resistances 43
213 Parasitic inductances 44
214 Driver models 45
2141 Lumped parameter models 45
2142 Distributed Parameter Models 46
22 The semiconductor junction 50
221 DC 51 Behavior
222 Incremental linear model 51
223 AC Model 53
2231 Investment capacity 53
2232 Direct capacity 54
23 The M O S transistor 54
231 D C Model 55
2311 NMOS 55
2312 PMOS 57
232 Incremental linear model 60
233 Model of A C 61
2331 Capacity dz g a te 61
2332 Joint capacity s 62
2333 Overlap capacity 64
3 CMOS Combinational Logic Circuits 67
31 Preliminary concepts 67
311 The transistor as a key 69
32 CMOS logic gates 71
321 Conceptual description 72
3211 The reversing gate 72
3212 The gate N A N D 74
3213 The gate Ñ O R 75
3214 Passage and transmission gates 75
3215 Three-state inverter 76
322 DC 77 Features
3221 The reversing gate 77
3222 NAND gate 85
3223 The NOR 91 gate
3224 Passage and transmission gates 95
3224I 95 Pitch NMOS Transistor
322A2 96 Pitch PMOS Transistor
32243 Transmission Gate 98
323 Complex gates 101
33 Other logical styles103
331 Pseudo-nMOS logic 103
332 Dynamic logic 106
333 Step gate logic 109
3331 Complementary Pass Transistor Logic (CPL) 111
4 Physical design of gates 113
41 Freehand diagrams 114
42 Basic gates116
421 The investor r116
422 NAND and NOR gates 117
423 Transmission gates 118
43 Com p le ja s gates 119
431 Euler path methodology 119
432 Weinberger Methodology 122
433 Standard cells 122
44 Good habits of the y o u t 123
5 Dynamics of combinational circuits 127
51 Transition times 129
511 Non-immediate entry transitions134
512 The transistor as a resistor 134
513 Computation of capabilities138
5131 Input capacity 138
5132 Safety capacity 140
52 CMO S142 Gates
521 The reversing gate143
522 NAND145 gate
523 The NOR gate R147
53 Sizing148
531 Chain of investors151
5311 Choice of number of stages 153
532 Branching effect155
54 Power Dissipation 158
541 Static dissipation 158
542 Dynamic dissipation 159
543 Short-circuit current dissipation 161
6 Sequential circuits 165
61 Latch and static registers167
611 Definitions 167
612 Temporary requirements 168
6121 Records168
6122 L atch 170
613 Regeneration and bistability 171
6131 Regenerative property 171
6132 Principle of bistability172
614 C M O S Implementations 175
6141 The tch 175
6142 Registry 179
61421 Non-ideal clock signals 180
6143 Flip-flop S R 183
62 Memories 186
621 ROM memories 187
622 Static RAM memories (SRAM) 190
6221 Read operation192
6222 Write operation194
623 Dynamic RAM memories (DRAM) 196
6231 Cell 3 T 197
6232 Cell I T 198
624 Decoders201
6241 File decoders 201
6242 Column decoders 202
63 Circuits not b ie s ta b le s203
631 Oscillators or astables 203
632 Monostable circuits 206
633 Schmitt trigger circuit207
A Elmore Method 209
B Design flow 211
C Practical aspects 213
Cl External connections: P a d s 213
C2 Latch-up215
C 3 Internal connections: power and clock 216
C31 Power 216
C 32 Clock 219
D SPICE 223 Models
D l Sources 223
D ll Independent sources223
D12 Dependent sources223
D2 Passive devices 224
D21 Resistors224
D22 Capacitors224
D23 Inductors224
D24 Mutual inductors 224
D3 Semiconductor devices 224
D31 Diode 225
D32 Bipolar Transistors 226
D33 MOS Transistors 227
D331 Level 1 Model 227
D332 Level 2 and 3 Models 228
D333 Level 4 Model 230
Circuits

->**********************************11_Roy_en.txt
Binary Number System 1
1.1 Introduction 1
1.2 Binary Number System 1
1.3 Representation of Numbers 2
1.3.1 Signed Magnitude Representation 2
1.3.2 One’s Complement Representation 3
1.3.3 Two’s Complement Representation 4
1.4 Binary Representation of Real Numbers 6
1.4.1 Fixed Point Data Format 6
1.5 Floating Point Data Format 7
1.6 Signed Number System 9
1.6.1 Binary SD Number System 9
1.6.2 SD Representation to Two’s Complement Representation 12
1.7 Conclusion 13
2 Basics of Verilog HDL 15
2.1 Introduction 15
2.2 Verilog Expressions 16
2.2.1 Verilog Operands 16
2.2.2 Verilog Operators 16
2.2.3 Concatenation and Replication 16
2.3 Data Flow Modelling 18
2.4 Behavioural Modelling 20
2.4.1 Initial Statement 20
2.4.2 Always Statement 21
2.4.3 Timing Control 21
2.4.4 Procedural Assignment 24
2.5 Structural Modelling 26
2.5.1 Gate-Level Modelling 26
2.5.2 Hierarchical Modelling 27
2.6 Mixed Modelling 28
2.7 Verilog Function 29
2.8 Verilog Task 30
2.9 File Handling 30
2.9.1 Reading from a Text File 31
2.9.2 Writing into a Text File 31
2.10 Test Bench Writing 32
2.11 Frequently Asked Questions 33
2.12 Conclusion 38
3 Basic Combinational Circuits 39
3.1 Introduction 39
3.2 Addition 39
3.3 Subtraction 41
3.4 Parallel Binary Adder 42
3.5 Controlled Adder/Subtractor 43
3.6 Multiplexers 44
3.7 De-Multiplexers 44
3.8 Decoders 45
3.9 Encoders 45
3.10 Majority Voter Circuit 46
3.11 Data Conversion Between Binary and Gray Code 47
3.12 Conversion Between Binary and BCD Code 48
3.12.1 Binary to BCD Conversion 49
3.12.2 BCD to Binary Conversion 51
3.13 Parity Generators/Checkers 52
3.14 Comparators 53
3.15 Constant Multipliers 55
3.16 Frequently Asked Questions 57
3.17 Conclusion 60
4 Basic Sequential Circuits 61
4.1 Introduction 61
4.2 Different Flip-Flops 61
4.2.1 SR Flip-Flop 62
4.2.2 JK Flip-Flop 63
4.2.3 D Flip-Flop 65
4.2.4 T Flip-Flop 67
4.2.5 Master-Slave D Flip-Flop 68
4.3 Shift Registers 68
4.3.1 Serial In Serial Out 69
4.3.2 Serial In Parallel Out 69
4.3.3 Parallel In Serial Out 70
4.3.4 Parallel In Parallel Out 71
4.4 Sequence Generator 72
4.5 Pseudo Noise Sequence Generator 73
4.6 Synchronous Counter Design 75
4.7 Loadable Counter 77
4.7.1 Loadable Up Counter 78
4.7.2 Loadable Down Counter 78
4.8 Even and Odd Counter 79
4.9 Shift Register Counters 80
4.10 Phase Generation Block 82
4.11 Clock Divider Circuits 82
4.11.1 Clock Division by Power of 2 83
4.11.2 Clock Division by 3 84
4.11.3 Clock Division by 6 85
4.11.4 Programmable Clock Divider Circuit 86
4.12 Frequently Asked Questions 86
4.13 Conclusion 88
5 Memory Design 89
5.1 Introduction 89
5.2 Controlled Register 89
5.3 Read OnlyMemory 90
5.3.1 Single Port ROM 90
5.3.2 Dual Port ROM(DPROM) 92
5.4 Random Access Memory (RAM) 93
5.4.1 Single Port RAM(SPRAM) 93
5.4.2 Dual Port RAM(DPRAM) 94
5.5 Memory Initialization 97
5.6 Implementing Bigger Memory Element Using Smaller Memory Elements 97
5.7 Implementation ofMemory Elements 98
5.8 Conclusion 100
6 Finite State Machines 101
6.1 Introduction 101
6.2 FSM Types 101
6.3 Sequence Detector Using Mealy Machine 103
6.4 Sequence Detector Using Moore Machine 107
6.5 Comparison of Mealy and Moore Machine 111
6.6 FSM-Based Serial Adder Design 111
6.7 FSM-Based Vending Machine Design 113
6.8 State Minimization Techniques 115
6.9 Row Equivalence Method 115
6.10 Implication ChartMethod 116
6.11 State Partition Method 119
6.12 Performance of State Minimization Techniques 120
6.13 Verilog Modelling of FSM-Based Systems 120
6.14 Frequently Asked Questions 123
6.15 Conclusion 126
7 Design of Adder Circuits 127
7.1 Introduction 127
7.2 Ripple Carry Adder 127
7.3 Carry Look-Ahead Adder 128
7.3.1 Higher Bit Adders Using CLA 130
7.3.2 Prefix Tree Adders 132
7.4 Manchester Carry Chain Module (MCC) 136
7.5 Carry Skip Adder 137
7.6 Carry Increment Adder 137
7.7 Carry Select Adder 137
7.8 Conditional Sum Adder 138
7.9 Ling Adders 139
7.10 Hybrid Adders 140
7.11 Multi-operand Addition 141
7.11.1 Carry Save Addition 141
7.11.2 Tree of Carry Save Adders 142
7.12 BCD Addition 142
7.13 Conclusion 144
8 Design of Multiplier Circuits 145
8.1 Introduction 145
8.2 Sequential Multiplication 145
8.3 Array Multipliers 146
8.4 Partial Product Generation and Reduction 149
8.4.1 Booth’s Multiplication 149
8.4.2 Radix-4 Booth’s Algorithm 150
8.4.3 Canonical Recoding 154
8.4.4 An Alternate 2-bit at-a-time Multiplication Algorithm 154
8.4.5 Implementing Larger Multipliers Using Smaller Ones 156
8.5 Accumulation of Partial Products 156
8.5.1 Accumulation of Partial Products for Unsigned Numbers 157
8.5.2 Accumulation of Partial Products for Signed Numbers 159
8.5.3 Alternative Techniques for Partial Product Accumulation 162
8.6 Wallace and Dedda Multiplier Design 163
8.7 Multiplication Using Look-Up Tables 167
8.8 Dedicated Square Block 168
8.9 Architectures Based on VEDIC Arithmetic 170
8.9.1 VEDIC Multiplier 170
8.9.2 VEDIC Square Block 171
8.9.3 VEDIC Cube Block 172
8.10 Conclusion 175
9 Division and Modulus Operation 177
9.1 Introduction 177
9.2 Sequential Division Methods 177
9.2.1 Restoring Division 178
9.2.2 Unsigned Array Divider 180
9.2.3 Non-restoring Division 181
9.2.4 Conversion from Signed Binary to Two’s Complement 184
9.3 Fast Division Algorithms 185
9.3.1 SRT Division 185
9.3.2 SRT Algorithm Properties 186
9.4 Iterative Division Algorithms 187
9.4.1 Goldschmidt Division 187
9.4.2 Newton–Raphson Division 187
9.5 Computation of Modulus 188
9.6 Conclusion 191
10 Square Root and its Reciprocal 193
10.1 Introduction 193
10.2 Slow Square Root Computation Methods 193
10.2.1 Restoring Algorithm 194
10.2.2 Non-restoring Algorithm 195
10.3 Iterative Algorithms for Square Root and its Reciprocal 197
10.3.1 Goldschmidt Algorithm 197
10.3.2 Newton–Raphson Iteration 198
10.3.3 Halley’sMethod 199
10.3.4 Bakhshali Method 199
10.3.5 Two Variable IterativeMethod 199
10.4 Fast SRT Algorithm for Square Root 200
10.5 Taylor Series Expansion Method 200
10.5.1 Theory 200
10.5.2 Implementation 202
10.6 Function Evaluation by Bipartite Table Method 203
10.7 Conclusion 205
11 CORDIC Algorithm 207
11.1 Introduction 207
11.2 Theoretical Background 207
11.3 VectoringMode 212
11.3.1 Computation of Sine and Cosine 213
11.4 Linear Mode 214
11.4.1 Multiplication 215
11.4.2 Division 215
11.5 Hyperbolic Mode 215
11.5.1 Square Root Computation 216
11.6 CORDIC Algorithm Using Redundant Number System 217
11.6.1 Redundant Radix-2-Based CORDIC Algorithm 217
11.6.2 Redundant Radix-4-Based CORDIC Algorithm 219
11.7 Example of CORDIC Iteration 219
11.8 Implementation of CORDIC Algorithms 219
11.8.1 Parallel Architecture 220
11.8.2 Serial Architecture 220
11.8.3 Improved CORDIC Architectures 222
11.9 Application 225
11.10 Conclusion 225
12 Floating Point Architectures 227
12.1 Introduction 227
12.2 Floating Point Representation 228
12.3 Fixed Point to Floating Point Conversion 230
12.4 Leading Zero Counter 231
12.5 Floating Point Addition 233
12.6 Floating Point Multiplication 236
12.7 Floating Point Division 238
12.8 Floating Point Comparison 239
12.9 Floating Point Square Root 240
12.10 Floating Point to Fixed Point Conversion 242
12.11 Conclusion 243
13 Timing Analysis 245
13.1 Introduction 245
13.2 Timing Definitions 246
13.2.1 Slew ofWaveform 246
13.2.2 Clock Jitter 246
13.2.3 Clock Latency 247
13.2.4 Launching and Capturing Flip-Flop 248
13.2.5 Clock Skew 248
13.2.6 Clock Uncertainty 249
13.2.7 Clock-to-Q Delay 249
13.2.8 Combinational Logic Timing 250
13.2.9 Min andMax Timing Paths 250
13.2.10 Clock Domains 251
13.2.11 Setup Time 251
13.2.12 Hold Time 251
13.2.13 Slack 252
13.2.14 Required Time and Arrival Time 253
13.2.15 Timing Paths 253
13.3 Timing Checks 253
13.3.1 Setup Timing Check 253
13.3.2 Hold Timing Check 254
13.4 Timing Checks for Different Timing Paths 254
13.4.1 Setup Check for Flip-Flop to Flip-Flop Timing Path 255
13.4.2 Setup and Hold Check for Input to Flip-Flop Timing Path 257
13.4.3 Setup Check for Flip-Flop to Output Timing Path 258
13.4.4 Setup Check for Input to Output Timing Path 258
13.4.5 Multicycle Paths 259
13.4.6 False Paths 260
13.4.7 Half Cycle Paths 260
13.5 Asynchronous Checks 261
13.5.1 Recovery Timing Check 261
13.5.2 Removal Timing Check 262
13.6 Maximum Frequency Computation 262
13.7 Maximum Allowable Skew 263
13.8 Frequently Asked Questions 266
13.9 Conclusion 268
14 Digital System Implementation 269
14.1 Introduction 269
14.2 FPGA Implementation 270
14.2.1 Internal Structure of FPGA 270
14.2.2 FPGA Implementation Using XILINX EDA Tool 276
14.2.3 Design Verification 279
14.2.4 FPGA Editor 280
14.3 ASIC Implementation 280
14.3.1 Simulation and Synthesis 281
14.3.2 Placement and Routing 283
14.4 Frequently Asked Questions 292
14.5 Conclusion 295
15 Low-Power Digital System Design 297
15.1 Introduction 297
15.2 Different Types of Power Consumption 297
15.2.1 Switching Power 298
15.2.2 Short Circuit Power 301
15.2.3 Leakage Power 301
15.2.4 Static Power 301
15.3 Architecture-Driven Voltage Scaling 302
15.3.1 Serial Architecture 302
15.3.2 Parallel Architecture 303
15.3.3 Pipeline Architecture 304
15.4 Algorithmic Optimization 304
15.4.1 Minimizing the Hardware Complexity 305
15.4.2 Selection of Data Representation Techniques 306
15.5 Architectural Optimization 307
15.5.1 Choice of Data Representation Techniques 307
15.5.2 Ordering of Input Signals 308
15.5.3 Reducing Glitch Activity 308
15.5.4 Choice of Topology 309
15.5.5 Logic Level Power Down 309
15.5.6 Synchronous Versus Asynchronous 309
15.5.7 Loop Unrolling 310
15.5.8 Operation Reduction 311
15.5.9 Substitution of Operation 313
15.5.10 Re-timing 314
15.5.11 Wordlength Reduction 316
15.5.12 Resource Sharing 316
15.6 Frequently Asked Questions 317
15.7 Conclusion 319
16 Digital System Design Examples 321
16.1 FPGA Implementation FIR Filters 322
16.1.1 FIR Low-Pass Filter 323
16.1.2 Advanced DSP Blocks 324
16.1.3 Different Filter Structures 325
16.1.4 Performance Estimation 330
16.1.5 Conclusion 332
16.1.6 Top Module for FIR Filter in Transposed Direct Form 332
16.2 FPGA Implementation of IIR Filters 333
16.2.1 IIR Low-Pass Filter 334
16.2.2 Different IIR Filter Structures 335
16.2.3 Pipeline Implementation of IIR Filters 338
16.2.4 Performance Estimation 342
16.2.5 Conclusion 344
16.3 FPGA Implementation of K-Means Algorithm 345
16.3.1 K-Means Algorithm 346
16.3.2 Example of K-Means Algorithm 347
16.3.3 Proposed Architecture 348
16.3.4 Design Performance 351
16.3.5 Conclusion 352
16.4 Matrix Multiplication 352
16.4.1 Matrix Multiplication by Scalar–Vector Multiplication 353
16.4.2 Matrix Multiplication by Vector–Vector Multiplication 354
16.4.3 Systolic Array for Matrix Multiplication 355
16.5 Sorting Architectures 359
16.5.1 Parallel Sorting Architecture 1 359
16.5.2 Parallel Sorting Architecture 2 359
16.5.3 Serial Sorting Architecture 360
16.5.4 Sorting Processor Design 361
16.6 Median Filter for Image De-noising 363
16.6.1 Median Filter 363
16.6.2 FPGA Implementation of Median Filter 365
16.7 FPGA Implementation of 8-Point FFT 367
16.7.1 Data Path for 8-Point FFT Processor 368
16.7.2 Control Path for 8-Point FFT Processor 370
16.8 Interfacing ADC Chips with FPGA Using SPI Protocol 371
16.9 Interfacing DAC Chips with FPGA Using SPI Protocol 378
16.10 Interfacing External Devices with FPGA Using UART 382
16.11 Conclusion 388
17 Basics of System Verilog 391
17.1 Introduction 391
17.2 Language Elements 391
17.2.1 Logic Literal Values 391
17.2.2 Basic Data Types 392
17.2.3 User Defined Data-Types 393
17.2.4 Enumeration Data Type 393
17.2.5 Arrays 394
17.2.6 Dynamic Arrays 395
17.2.7 Associative Array 396
17.2.8 Queues 396
17.2.9 Events 397
17.2.10 String Methods 397
17.3 Composite Data Types 398
17.3.1 Structures 398
17.3.2 Unions 400
17.3.3 Classes 401
17.4 Expressions 402
17.4.1 Parameters and Constants 402
17.4.2 Variables 403
17.4.3 Operators 404
17.4.4 SetMembership Operator 405
17.4.5 Static Cast Operator 405
xxii Contents
17.4.6 Dynamic Casting 406
17.4.7 Type Operator 407
17.4.8 Concatenation of String Data Type 407
17.4.9 Streaming Operators 407
17.5 Behavioural Modelling 408
17.5.1 Procedural Constructs 408
17.5.2 Loop Statements 410
17.5.3 Case Statement 413
17.5.4 If Statement 414
17.5.5 Final Statement 415
17.5.6 Disable Statement 416
17.5.7 Event Control 417
17.5.8 Continuous Assignment 417
17.5.9 Parallel Blocks 418
17.5.10 Process Control 419
17.6 Structural Modelling 420
17.6.1 Module Prototype 420
17.7 Summary 423
18 Advanced FPGA Implementation Techniques 425
18.1 Introduction 425
18.2 System-On-Chip Implementation 425
18.2.1 Implementations Using SoC FPGAs 427
18.2.2 AXI Protocol 430
18.2.3 AXI Protocol Features 431
18.3 Partial Re-configuration (PR) 432
18.3.1 Dynamic PR 432
18.3.2 Advantages of DPR 432
18.3.3 DPR Techniques 433
18.3.4 DPR Terminology 434
18.3.5 DPR Tools 436
18.3.6 DPR Flow 436
18.3.7 Communication Between Reconfigurable Modules 437
18.4 Conclusion 441
References 443
Index 447
->**********************************12_Urquia_en.txt
Index 5
VHDL 13 code listing
1 Digital Hardware Design Fundamentals 25
1.1 Introduction 29
1.2 Languages for hardware description 30
1.2.1 Uses of an HDL program 31
1.2.2 Most widely used HDL 31
1.3 Digital circuit design cycle 32
1.4 Integrated circuit technologies 34
1.4.1 Classification of technologies 34
1.4.2 Comparison between technologies 38
1.5 Properties of digital circuits 42
1.5.1 Device delay 42
1.5.2 Concurrent execution 44
1.5.3 Marginal designs 45
1.5.4 Signal strength 45
1.6 Circuit test 46
1.6.1 Test in manufacturing 47
1.6.2 Functional test 49
5
The VHDL code used to illustrate the theoretical explanations, as well as the designs and banks of
test proposed as a solution to the self-check exercises, are available at
the following URL: https://canal.uned.es/series/64149eb43056d535ce6fe473
DESIGN AND ANALYSIS OF DIGITAL CIRCUITS WITH VHDL
1.6.3 Functional test programs 49
1.6.4 Test bench 51
1.7 Representations and levels of abstraction 52
1.7.1 System representation 52
1.7.2 Levels of abstraction 53
1.7.3 VHDL in the development flow 57
1.8 Basic concepts through an example 58
1.8.1 Behavior at the level of logical functions 59
1.8.2 Structure description 64
1.8.3 Abstract description of behavior 66
1.8.4 Test bench 69
1.8.5 Configuration 71
1.9 Simulation of VHDL code through an example 72
1.9.1 Design of a tristate buffer 72
1.9.2 Test bench design 73
1.10 Recommended readings 75
1.11 Self-check exercises 76
1.12 Solutions to exercises 80
2 VHDL Basics 83
2.1 Introduction 87
2.2 Design units 87
2.3 Entity 89
2.3.1 Port 90 clause
2.3.2 Generic Clause 91
2.3.3 Declarations 93
2.3.4 Sentences 93
2.3.5 Summary of entity syntax 93
2.4 Architecture 94
6
INDEX
2.5 Concurrent assignments 95
2.5.1 Simple concurrent assignments 96
2.5.2 Conditional concurrent assignments 98
2.5.3 Concurrent selection assignments 102
2.5.4 Sensitivity of concurrent sentences 105
2.6 generate 106 statement
2.6.1 Iterative generate statement 106
2.6.2 Conditional generate statement 107
2.7 Process block 107
2.7.1 wait 109 statements
2.7.2 Sensitivity list 111
2.8 Sequential code 113
2.8.1 Sequential assignment to a signal 113
2.8.2 Sequential assignment to a variable 114
2.8.3 if 115 statement
2.8.4 Case 119 ruling
2.8.5 Loop for 123
2.9 Structure description 125
2.9.1 Designs with regular structure 130
2.10 Parameterization 133
2.10.1 Behavior parameterization 133
2.10.2 Structure parameterization 133
2.11 Signals, variables and constants 134
2.12 Data types and operators 136
2.12.1 Predefined types in VHDL 137
2.12.2 IEEE.std logic 1164 140 package types
2.12.3 Operators on bit vector and std logic vector 144
2.12.4 IEEE.numeric std 147 packet types
7
DESIGN AND ANALYSIS OF DIGITAL CIRCUITS WITH VHDL
2.12.5 Time and string types 153
2.12.6 User-defined types 153
2.13 Attributes 156
2.14 Libraries 157
2.15 Assert 159
2.16 Subprograms 159
2.16.1 Functions 159
2.16.2 Procedures 161
2.16.3 Differences between functions and procedures 164
2.17 Packages 165
2.18 Recommended readings 166
2.19 Self-check exercises 168
2.20 Solutions to exercises 175
3 Simulation of VHDL 189 code
3.1 Introduction 193
3.2 VHDL 194 code processing
3.3 Build order 195
3.4 Drivers 196
3.5 Initialization 199
3.5.1 Example: signal with a 200 driver
3.5.2 Example: signal with two drivers 201
3.6 Signal attributes 204
3.7 The delta 205 delay
3.8 Driver transaction queue management 209
3.8.1 Example: Waveform Simulation with Inertial Delay 209
3.8.2 Example: Transport Delay Waveform Simulation
212
3.9 Example: simulation of a simple circuit 214
8
INDEX
3.10 Recommended readings 217
3.11 Self-check exercises 218
3.12 Solutions to exercises 229
4 Combinational logic design 263
4.1 Introduction 267
4.2 Design for combinational logic synthesis 267
4.2.1 Use of concurrent sentences 268
4.2.2 Use of process 270 blocks
4.3 Logic functions 271
4.3.1 Circuit Design 271
4.3.2 Test bench programming 273
4.4 4-input multiplexer 275
4.4.1 Design using sequential statements 275
4.4.2 Design using concurrent statements 279
4.5 1-bit full subtractor 281
4.5.1 Description of behavior 281
4.5.2 Structure description 283
4.5.3 Test bench programming 286
4.6 1-bit full adder 291
4.6.1 Circuit Design 292
4.6.2 Test bench 294
4.7 Arithmetic Logic Unit 296
4.7.1 Design of the ALU 296
4.7.2 Test bench programming 298
4.8 Recommended readings 302
4.9 Self-check exercises 303
4.10 Solutions to exercises 310
9
DESIGN AND ANALYSIS OF DIGITAL CIRCUITS WITH VHDL
5 Records and memories 341
5.1 Introduction 345
5.2 4-bit register 345
5.2.1 Description of behavior 346
5.2.2 Test bench 347
5.3 Multi-function register 349
5.3.1 Description of behavior 349
5.3.2 Test bench 352
5.4 Shift register 355
5.4.1 Description of behavior 355
5.4.2 Test bench 356
5.4.3 Test bench with access to file 359
5.5 Register file 363
5.5.1 Tristate Registry 364
5.5.2 Structural description of register file 365
5.5.3 Drivers and 367 resolution function
5.5.4 Register file 367 test bench
5.5.5 Description of the behavior of register file 371
5.6 Bidirectional bus and memories 373
5.6.1 Read-only memory 373
5.6.2 Read and write memory 375
5.6.3 Bidirectional bus 376
5.7 Recommended readings 378
5.8 Self-check exercises 379
5.9 Solutions to exercises 385
6 Sequential Logic Design 403
6.1 Introduction 407
6.2 Design of finite state machines 407
10
INDEX
6.2.1 Sequence detector circuit 408
6.3 Synthesis of sequential logic 410
6.3.1 Incomplete conditional statements 411
6.3.2 Complete conditional statements 411
6.3.3 Delays 411
6.3.4 Initialization 412
6.3.5 Process blocks 412
6.4 Flip-flop JK 413
6.4.1 Design of the 414 flip-flop
6.4.2 Test bench 415
6.5 Moore 418 Finite State Machines
6.5.1 Machine Design 418
6.5.2 Test bench 421
6.5.3 Structural modeling 424
6.6 Mealy 426 finite state machines
6.6.1 Machine Design 427
6.6.2 Test bench 433
6.7 Safe finite state machines 436
6.8 Recommended readings 437
6.9 Self-check exercises 439
6.10 Solutions to exercises 449
7 Transfer methodology between 501 records
7.1 Introduction 505
7.2 Transfer operations between registers 506
7.2.1 Basic RT Operation 506
7.2.2 RT 508 Program
7.3 Finite state machines with data paths 509
7.3.1 Multiple RT operations and 510 data path
11
DESIGN AND ANALYSIS OF DIGITAL CIRCUITS WITH VHDL
7.3.2 Control logic using FSM 510
7.3.3 FSMD 511 Basic Block Diagram
7.4 Description of the RT program using VHDL 513
7.5 Sequence detector circuit 516
7.6 Control of a vending machine 518
7.6.1 Handshaking protocol 519
7.6.2 Description of algorithm 520
7.6.3 Control circuit design 522
7.6.4 Test bench programming 525
7.7 Recommended readings 527
7.8 Self-check exercises 528
7.9 Solutions to exercises 532
A Introduction to using ModelSim 547
A.1 Installation 549
A.2 Edition and compilation of a model 549
A.2.1 Main simulator window 549
A.2.2 Steps to create a 550 project
A.2.3 Add files to project 551
A.2.4 Compilation of 556 files
A.2.5 Test bench 558
A.3 Simulation, visualization and debugging 560
A.3.1 Activation of 560 simulation mode
A.3.2 Viewing results 562
A.3.3 Simulation execution 563
A.3.4 Insertion of breakpoints 564
Alphabetical index 567
Bibliography 573
12
VHDL CODE LIST
1.1 Entity of the parity detector circuit60
1.2 Architecture of the parity detector describing the behavior using the logic function60
1.3 Architecture of the parity detector describing the behavior using the XOR63 logic function
1.4 Inverter gate65
1.5 XOR gate with two inputs65
1.6 Architecture of the parity detector describing the circuit structure65
1.7 Architecture of the parity detector described using an XOR67 network
1.8 Architecture of the parity detector described by an algorithm68
1.9 Parity detector test bench70
1.10 Configuration for parity detector test bench simulation71
1.11 Tri-state buffer73
1.12 Tri-state buffer testbench74
1.13 Design of the control circuit of a car security alarm79
1.14 Alternative design of the car alarm control circuit79
2.1 Parity detector circuit88
2.2 Bad code, causing a compilation error92
2.3 Correct description of the circuit shown in Figure 2.392
2.4 4-input 8-bit multiplexer100
2.5 2-input binary decoder100
2.6 4 to 2 encoder with priority100
13
DESIGN AND ANALYSIS OF DIGITAL CIRCUITS WITH VHDL
2.7 4-input 8-bit multiplexer103
2.8 2-input binary decoder103
2.9 4 to 2 encoder with priority103
2.10 Flip-flop D with asynchronous reset activated at level LOW112
2.11 4-input 8-bit multiplexer116
2.12 2-input binary decoder116
2.13 4 to 2 encoder with priority117
2.14 4-input 8-bit multiplexer120
2.15 2-input binary decoder120
2.16 4 to 2 encoder with priority121
2.17 Bitwise XOR of two 4-bit signals124
2.18 XOR the bits of a 4-bit signal124
2.19 Structural description at the logic gate level of a multiplexer
of two one-bit signals128
2.20 Structural description of a 4-bit 2-signal multiplexer129
2.21 AND131 8-door array
2.22 8-bit parity detector132
2.23 The conv integer function converts a parameter of type std logic -
vector to an integer161
2.24 Procedure that returns two input parameters in order164
2.25 Defining a function in a package167
2.26 Using a function defined in a package167
2.27 Design corresponding to Exercise 2.3169
2.28 Design corresponding to Exercise 2.1176
2.29 Test bank corresponding to Exercise 2.1176
2.30 Design corresponding to Exercise 2.2177
2.31 “One-shot” circuit design179
2.32 One-shot circuit test bench179
2.33 Design of a 2:4 decoder with enable180 input
14
VHDL CODE LIST
2.34 Test bench of a 2:4 decoder with enable181 input
3.1 Code corresponding to Exercise 3.1218
3.2 Code corresponding to Exercise 3.2219
3.3 Exercise Design 3.3219
3.4 Test bench for Exercise 3.3220
3.5 Exercise Design 3.4221
3.6 Test bench for Exercise 3.4221
3.7 Design corresponding to Exercise 3.5222
3.8 Test bank corresponding to Exercise 3.5223
3.9 Design corresponding to Exercise 3.6223
3.10 Test bank corresponding to Exercise 3.6224
3.11 Design corresponding to Exercise 3.7225
3.12 Design corresponding to Exercise 3.8226
3.13 Design corresponding to Exercise 3.9227
3.14 Design corresponding to Exercise 3.10228
4.1 Design by describing logical functions272
4.2 Test bench of the circuit that implements the two logical functions272
4.3 Design of a 4:1 MUX using an if275 statement
4.4 Description of the 4:1 MUX using if and case276 statements
4.5 MUX Test Bench 4:1277
4.6 Misdescription of the MUX architecture 4:1279
4.7 Design of a 4:1 MUX using a concurrent statement280
4.8 Design of a 4:1 MUX using two concurrent statements280
4.9 Description of the behavior of a complete one-bit282 subtractor
4.10 Exclusive OR gate with 2 inputs284
4.11 1-input inverter284
4.12 2-input AND gate284
4.13 3-input OR gate284
15
DESIGN AND ANALYSIS OF DIGITAL CIRCUITS WITH VHDL
4.14 Description of the structure of a complete one-bit subtractor285
4.15 One-bit full subtractor testbench287
4.16 One-bit complete subtractor test bench using a procedure.
289
4.17 One-bit full subtractor testbench using a function290
4.18 2-input AND with delay292
4.19 3-input OR with delay292
4.20 2-input exclusive OR with delay 293
4.21 Package in which the logic gates are declared293
4.22 1-bit full adder294
4.23 1-bit full adder testbench295
4.24 Definition of global constants of the ALU297
4.25 ALU designed using a concurrent statement297
4.26 ALU designed using a process298 block
4.27 Global constants of the ALU299 test bench
4.28 ALU299 test bench
4.29 Design of a 4:2 encoder with priority 310
4.30 Test bench of a 4:2 encoder with priority311
4.31 Design of the 4-bit comparator circuit for X < 5313
4.32 4-bit comparator circuit test bench for X < 5314
4.33 7-segment BCD decoder described using a statement
case315
4.34 BCD316 decoder test bench
4.35 BCD decoder described using an if317 statement
4.36 BCD decoder described using an assignment statement
conditional concurrent318
4.37 BCD decoder described using a with select319 statement
4.38 N-bit adder design320
4.39 4-bit adder testbench321
16
VHDL CODE LIST
4.40 Displacer Circuit Design322
4.41 Displacer circuit test bench323
4.42 Equality comparator of two 1-bit numbers325
4.43 Equality comparator of two N-bit numbers325
4.44 Test bench of the equality comparator of two numbers of N
bits326
4.45 Package with the global constants of the ALU327
4.46 Design of the ALU whose circuit is shown in Figure 4.12328
4.47 Package with the constants used in the ALU329 test bench
4.48 ALU329 test bench
4.49 Design of a 1-input NOT gate333
4.50 Design of a 4-input AND gate335
4.51 Design of a 3 to 8-bit decoder335
4.52 Test bench of a 3 to 8 bit decoder336
4.53 Design of the binary code to Gray code converter, using a
process block with a case338 statement
4.54 Design of the binary code to Gray code converter, using a
concurrent selection assignment (with - select)339
4.55 Design of the binary code to Gray code converter, describing the
circuit structure at the logic gate level339
4.56 Gray340 Binary to Code Converter Testbed
5.1 Design of a 4-bit register with synchronous reset346
5.2 Test bench of a 4-bit register with synchronous reset348
5.3 Design of a 4-bit multifunction register350
5.4 Test bench of a 4-bit multifunction register352
5.5 Design of a 32-bit shift register356
5.6 32-bit shift register testbench357
5.7 Registry test bench with access to file359
5.8 Design of a tri-state registry365
17
DESIGN AND ANALYSIS OF DIGITAL CIRCUITS WITH VHDL
5.9 Structural design of register file366
5.10 Register file test bench, with access to file368
5.11 Design of the register file by describing the behavior372
5.12 Read-only memory374
5.13 Read and write memory375
5.14 Bidirectional bus376
5.15 Design of a 4-bit shift register using variables385
5.16 Design of a 4-bit shift register using signals386
5.17 Incorrect design of a 4-bit shift register386
5.18 Test bench of a 4-bit shift register with
serial input and output387
5.19 N-bit shift register, with serial input and output388
5.20 4-bit serial-to-parallel and parallel-to-serial register389
5.21 Test bench for serial-to-parallel and parallel-to-serial recording of
4 bits390
5.22 Global ALU and Register Constants392
5.23 ALU circuit design and register shown in Figure 5.15393
5.24 Global testbench constants394
5.25 ALU circuit test bench and register394
5.26 ROM397 design
5.27 ROM398 test bench
5.28 RAM399 Design
5.29 RAM400 test bench
5.30 Detector circuit design401
5.31 Detector circuit test bench402
6.1 Design of a JK flip-flop with asynchronous reset414
6.2 Test bench of a JK416 flip-flop
6.3 Package with the coding of the states418
6.4 Design of the Moore machine of Figure 6.7419
18
VHDL CODE LIST
6.5 Moore machine test bench of Figure 6.7422
6.6 Structural design of Moore425 machine
6.7 Package with the coding of the states427
6.8 Design of the Mealy machine in Figure 6.11427
6.9 Alternative design of the Mealy machine of Figure 6.11430
6.10 Non-exhaustive test bench of the Mealy machine in Figure
6.11432
6.11 Mealy machine test bench of Figure 6.11433
6.12 Design of a secure FSM438
6.13 Design of a D449 latch
6.14 D449 latch test bench
6.15 Design of an RS451 flip-flop
6.16 RS452 flip-flop test bench
6.17 Design of a D flip-flop with enable, set and clear454 signals
6.18 D455 flip-flop test bench
6.19 Module 4457 upcounter design constants
6.20 Design of a module 4458 ascending counter
6.21 Test bench of an ascending counter module 4459
6.22 Structural design of the module 4462 up-counter
6.23 Global constants that encode states464
6.24 Signal generator design464
6.25 Signal generator test bench465
6.26 Frequency divider design by 3467
6.27 Frequency divider test bench for 3468
6.28 Signal generator circuit469
6.29 Signal generator circuit test bench471
6.30 Detector circuit of 3 or more consecutive ones472
6.31 Sequence detector circuit test bench474
6.32 BCD477 Counter Design
19
DESIGN AND ANALYSIS OF DIGITAL CIRCUITS WITH VHDL
6.33 BCD478 Counter Test Bench
6.34 Design of the “1011”480 sequence detector
6.35 “1011”482 sequence detector test bench
6.36 Design of 4-bit up and down binary counter484
6.37 4 Up and Down Binary Counter Test Bench
bits485
6.38 Global constants of the two semaphore controller487
6.39 Two-traffic light controller design488
6.40 Two Traffic Light Controller Testbed490
6.41 Global microwave controller constants493
6.42 Microwave Controller Design493
6.43 Microwave Controller Test Bench496
7.1 VHDL encoding of an RT515 algorithm
7.2 Two designs of a detector circuit of the sequence 0111 1110517
7.3 Vending machine circuit constants522
7.4 Vending machine control circuit523
7.5 Vending Machine Control Circuit Test Bench525
7.6 Circuit that calculates the greatest common factor of two numbers534
7.7 Circuit test bench that calculates the greatest common factor of
two numbers535
7.8 Circuit that calculates the average of 4 4-bit numbers537
7.9 Circuit test bench that calculates the average of 4 numbers out of 4
bits538
7.10 Declaration of the global constant539
7.11 BCD to Binary540 Code Converter
7.12 BCD to Binary Code Converter Testbed540
7.13 Declaration of global design constants542
7.14 Circuit that calculates the exponentiation of two unsigned binary numbers542
7.15 Test bench of the circuit that calculates exponentiation544

->**********************************13_Brock_en.txt
1: INTRODUCTION: ANALOG VERSUS DIGITAL  1
11 DIFFERENCES BETWEEN ANALOG AND DIGITAL SYSTEMS  1
12 ADVANTAGES OF DIGITAL SYSTEMS OVER ANALOG SYSTEMS  3
2: NUMBER SYSTEMS  7
21 POSITIONAL NUMBER SYSTEMS  7
211 Generic Structure 8
212 Decimal Number System (Base 10)  9
213 Binary Number System (Base 2)  9
214 Octal Number System (Base 8)  10
215 Hexadecimal Number System (Base 16)  10
22 BASE CONVERSION  11
221 Converting to Decimal  11
222 Converting from Decimal  14
223 Converting Between 2n Bases  18
23 BINARY ARITHMETIC  22
231 Addition (Carries)  22
232 Subtraction (Borrows)  23
24 UNSIGNED AND SIGNED NUMBERS  25
241 Unsigned Numbers  25
242 Signed Numbers  26
3: DIGITAL CIRCUITRY AND INTERFACING  43
31 BASIC GATES  43
311 Describing the Operation of a Logic Circuit  43
312 The Buffer  45
313 The Inverter  46
314 The AND Gate  46
315 The NAND Gate  47
316 The OR Gate  47
317 The NOR Gate  47
318 The XOR Gate  48
319 The XNOR Gate  49
32 DIGITAL CIRCUIT OPERATION  50
321 Logic Levels  51
322 Output DC Specifications  51
323 Input DC Specifications  53
324 Noise Margins  53
325 Power Supplies  54
326 Switching Characteristics  56
327 Data Sheets  57
51 HISTORY OF HARDWARE DESCRIPTION LANGUAGES  154
33 LOGIC FAMILIES  62
331 Complementary Metal Oxide Semiconductors (CMOS)  62
332 Transistor-Transistor Logic (TTL)  71
333 The 7400 Series Logic Families  73
34 DRIVING LOADS  77
341 Driving Other Gates  77
342 Driving Resistive Loads  79
343 Driving LEDs  81
4: COMBINATIONAL LOGIC DESIGN  93
41 BOOLEAN ALGEBRA  93
411 Operations  94
412 Axioms  94
413 Theorems  95
42 COMBINATIONAL LOGIC ANALYSIS  111
421 Finding the Logic Expression from a Logic Diagram  111
422 Finding the Truth Table from a Logic Diagram  112
423 Timing Analysis of a Combinational Logic Circuit  113
43 COMBINATIONAL LOGIC SYNTHESIS  115
431 Canonical Sum of Products  115
432 The Minterm List (Σ)  116
433 Canonical Product of Sums (POS)  118
434 The Maxterm List (Π)  120
435 Minterm and Maxterm List Equivalence  122
44 LOGIC MINIMIZATION  124
441 Algebraic Minimization  124
442 Minimization Using Karnaugh Maps  125
443 Don’t Cares  137
444 Using XOR Gates  138
45 TIMING HAZARDS AND GLITCHES  141
5: VERILOG (PART 1)  153
52 HDL ABSTRACTION  157
53 THE MODERN DIGITAL DESIGN FLOW  160
54 VERILOG CONSTRUCTS  163
541 Data Types  164
542 The Module  168
543 Verilog Operators  171
55 MODELING CONCURRENT FUNCTIONALITY IN VERILOG  176
551 Continuous Assignment  176
552 Continuous Assignment with Logical Operators  176
553 Continuous Assignment with Conditional Operators  177
554 Continuous Assignment with Delay  179
61 DECODERS  193
71 SEQUENTIAL LOGIC STORAGE DEVICES  211
56 STRUCTURAL DESIGN AND HIERARCHY  182
561 Lower-Level Module Instantiation  182
562 Gate Level Primitives  184
563 User-Defined Primitives  185
564 Adding Delay to Primitives  186
57 OVERVIEW OF SIMULATION TEST BENCHES  187
6: MSI LOGIC  193
611 Example: One-Hot Decoder  194
612 Example: 7-Segment Display Decoder  196
62 ENCODERS  200
621 Example: One-Hot Binary Encoder  200
63 MULTIPLEXERS  202
64 DEMULTIPLEXERS  205
7: SEQUENTIAL LOGIC DESIGN  211
711 The Cross-Coupled Inverter Pair  211
712 Metastability  212
713 The SR Latch  214
714 The S’R’ Latch  217
715 SR Latch with Enable  219
716 The D-Latch  222
717 The D-Flip-Flop  223
72 SEQUENTIAL LOGIC TIMING CONSIDERATIONS  227
73 COMMON CIRCUITS BASED ON SEQUENTIAL STORAGE DEVICES  228
731 Toggle Flop Clock Divider  228
732 Ripple Counter  229
733 Switch Debouncing  230
734 Shift Registers  234
74 FINITE-STATE MACHINES  236
741 Describing the Functionality of an FSM  236
742 Logic Synthesis for an FSM  238
743 FSM Design Process Overview  245
744 FSM Design Examples  246
75 COUNTERS  254
751 2-Bit Binary Up Counter  254
752 2-Bit Binary Up/Down Counter  256
753 2-Bit Gray Code Up Counter  258
754 2-Bit Gray Code Up/Down Counter  260
755 3-Bit One-Hot Up Counter  262
756 3-Bit One-Hot Up/Down Counter  264
76 FINITE-STATE MACHINE’S RESET CONDITION  267
77 SEQUENTIAL LOGIC ANALYSIS  268
771 Finding the State Equations and Output Logic Expressions of an FSM  268
772 Finding the State Transition Table of an FSM  269
773 Finding the State Diagram of an FSM  270
774 Determining the Maximum Clock Frequency of an FSM  271
8: VERILOG (PART 2)  287
81 PROCEDURAL ASSIGNMENT  287
811 Procedural Blocks  287
812 Procedural Statements  290
813 Statement Groups  295
814 Local Variables  295
82 CONDITIONAL PROGRAMMING CONSTRUCTS  296
821 if-else Statements  296
822 case Statements  297
823 casez and casex Statements  299
824 forever Loops  299
825 while Loops  299
826 repeat Loops  300
827 for Loops  300
828 disable  301
83 SYSTEM TASKS  302
831 Text Output  302
832 File Input/Output  303
833 Simulation Control and Monitoring  305
84 TEST BENCHES  306
841 Common Stimulus Generation Techniques  307
842 Printing Results to the Simulator Transcript  308
843 Automatic Result Checking  309
844 Using Loops to Generate Stimulus  311
845 Using External Files in Test Benches  312
9: BEHAVIORAL MODELING OF SEQUENTIAL LOGIC  319
91 MODELING SEQUENTIAL STORAGE DEVICES IN VERILOG  319
911 D-Latch  319
912 D-Flip-Flop  320
913 D-Flip-Flop with Asynchronous Reset  320
914 D-Flip-Flop with Asynchronous Reset and Preset  321
915 D-Flip-Flop with Synchronous Enable  322
92 MODELING FINITE STATE MACHINES IN VERILOG  323
921 Modeling the States  325
922 The State Memory Block  325
923 The Next-State Logic Block  325
924 The Output Logic Block  326
925 Changing the State Encoding Approach  328
1123 Programmable Interconnect Points (PIPs)  384
93 FSM DESIGN EXAMPLES IN VERILOG  329
931 Serial Bit Sequence Detector in Verilog  329
932 Vending Machine Controller in Verilog  331
933 2-Bit, Binary Up/Down Counter in Verilog  333
94 MODELING COUNTERS IN VERILOG  335
941 Counters in Verilog Using a Single Procedural Block  335
942 Counters with Range Checking  336
943 Counters with Enables in Verilog  336
944 Counters with Loads  337
95 RTL MODELING  338
951 Modeling Registers in Verilog  338
952 Registers as Agents on a Data Bus  339
953 Shift Registers in Verilog  341
10: MEMORY  347
101 MEMORY ARCHITECTURE AND TERMINOLOGY  347
1011 Memory Map Model  347
1012 Volatile vs Nonvolatile Memory  348
1013 Read Only vs Read/Write Memory  348
1014 Random Access vs Sequential Access  348
102 NONVOLATILE MEMORY TECHNOLOGY  349
1021 ROM Architecture  349
1022 Mask Read Only Memory  352
1023 Programmable Read Only Memory  353
1024 Erasable Programmable Read Only Memory  354
1025 Electrically Erasable Programmable Read Only Memory  356
1026 FLASH Memory  357
103 VOLATILE MEMORY TECHNOLOGY  358
1031 Static Random-Access Memory  358
1032 Dynamic Random-Access Memory  361
104 MODELING MEMORY WITH VERILOG  368
1041 Read Only Memory in Verilog  368
1042 Read/Write Memory in Verilog  369
11: PROGRAMMABLE LOGIC  375
111 PROGRAMMABLE ARRAYS  375
1111 Programmable Logic Array (PLA)  375
1112 Programmable Array Logic (PAL)  376
1113 Generic Array Logic (GAL)  377
1114 Hard Array Logic (HAL)  378
1115 Complex Programmable Logic Devices (CPLD)  378
112 FIELD PROGRAMMABLE GATE ARRAYS (FPGAS)  379
1121 Configurable Logic Block (or Logic Element)  380
1122 Look-Up Tables (LUTs)  381
12: ARITHMETIC CIRCUITS  389
121 ADDITION  389
13: COMPUTER SYSTEM DESIGN  419
131 COMPUTER HARDWARE  419
14: FLOATING-POINT SYSTEMS  465
141 OVERVIEW OF FLOATING-POINT NUMBERS  465
1124 Input/Output Block (IOBs)  385
1125 Configuration Memory  386
1211 Half Adders  389
1212 Full Adders  390
1213 Ripple Carry Adder  392
1214 Carry Look Ahead Adder  394
1215 Adders in Verilog  397
122 SUBTRACTION  402
123 MULTIPLICATION  405
1231 Unsigned Multiplication  405
1232 A Simple Circuit to Multiply by Powers of Two  408
1233 Signed Multiplication  408
124 DIVISION  411
1241 Unsigned Division  411
1242 A Simple Circuit to Divide by Powers of Two  414
1243 Signed Division  415
1311 Program Memory  420
1312 Data Memory  420
1313 Input/Output Ports  420
1314 Central Processing Unit  421
1315 A Memory-Mapped System  422
132 COMPUTER SOFTWARE  424
1321 Opcodes and Operands  425
1322 Addressing Modes  425
1323 Classes of Instructions  426
133 COMPUTER IMPLEMENTATION:AN 8-BIT COMPUTER EXAMPLE  433
1331 Top-Level Block Diagram  433
1332 Instruction Set Design  434
1333 Memory System Implementation  435
1334 CPU Implementation  439
134 ARCHITECTURE CONSIDERATIONS  460
1341 Von Neumann Architecture  460
1342 Harvard Architecture  460
1411 Limitations of Fixed-Point Numbers  465
1412 The Anatomy of a Floating-Point Number  466
1413 The IEEE 754 Standard  467
1414 Single-Precision Floating-Point Representation (32-Bit)  467
1415 Double-Precision Floating-Point Representation (64-Bit)  471
1416 IEEE 754 Special Values  474
1417 IEEE 754 Rounding Types  476
1418 Other Capabilities of the IEEE 754 Standard  477
142 IEEE 754 BASE CONVERSIONS  478
1421 Converting from Decimal into IEEE 754 Single-Precision Numbers  478
1422 Converting from IEEE 754 Single-Precision Numbers into Decimal  481
143 FLOATING-POINT ARITHMETIC  482
1431 Addition and Subtraction of IEEE 754 Numbers  482
1432 Multiplication and Division of IEEE 754 Numbers  490
144 FLOATING-POINT MODELING IN VERILOG  496
1441 Modeling Floating-Point Addition in Verilog  496
1442 Modeling Floating-Point Subtraction in Verilog  501
1443 Modeling Floating-Point Multiplication in Verilog  505
1444 Modeling Floating-Point Division in Verilog  508
APPENDIX A: LIST OF WORKED EXAMPLES  515
APPENDIX B: CONCEPT CHECK SOLUTIONS  521
INDEX  523
->**********************************14_Wakerly_en.txt
Preface xv
1 INTRODUCTION 1
1.1 About Digital Design 1
1.2 Analog versus Digital 3
1.3 Analog Signals 7
1.4 Digital Logic Signals 7
1.5 Logic Circuits and Gates 9
1.6 Software Aspects of Digital Design 13
1.7 Integrated Circuits 16
1.8 Logic Families and CMOS 19
1.9 CMOS Logic Circuits 20
1.10 Programmable Devices 25
1.11 Application-Specific ICs 27
1.12 Printed-Circuit Boards 28
1.13 Digital-Design Levels 29
1.14 The Name of the Game 33
1.15 Going Forward 34
Drill Problems 34
2 NUMBER SYSTEMS AND CODES 35
2.1 Positional Number Systems 36
2.2 Binary, Octal, and Hexadecimal Numbers 37
2.3 Binary-Decimal Conversions 39
2.4 Addition and Subtraction of Binary Numbers 42
2.5 Representation of Negative Numbers 44
2.5.1 Signed-Magnitude Representation 2.5.2 Complement Number Systems
2.5.3 Two’s-Complement Representation
2.5.4 Ones’-Complement Representation 2.5.5 Excess Representations
2.6 Two’s-Complement Addition and Subtraction 48
2.6.1 Addition Rules 2.6.2 A Graphical View 2.6.3 Overflow
2.6.4 Subtraction Rules 2.6.5 Two’s-Complement and Unsigned Binary Numbers
2.7 Ones’-Complement Addition and Subtraction 52
2.8 Binary Multiplication 54
2.9 Binary Division 56
2.10 Binary Codes for Decimal Numbers 57
2.11 Gray Code 60
2.12 Character Codes 62
2.13 Codes for Actions, Conditions, and States 64
2.14 n-Cubes and Distance 66
2.15 Codes for Detecting and Correcting Errors 67
2.15.1 Error-Detecting Codes
2.15.2 Error-Correcting and Multiple-Error-Detecting Codes
2.15.3 Hamming Codes 2.15.4 CRC Codes
2.15.5 Two-Dimensional Codes 2.15.6 Checksum Codes
2.15.7 m-out-of-n Codes
2.16 Codes for Transmitting and Storing Serial Data 78
2.16.1 Parallel and Serial Data 2.16.2 Serial Line Codes
References 82
Drill Problems 83
Exercises 85
3 SWITCHING ALGEBRA AND COMBINATIONAL LOGIC 89
3.1 Switching Algebra 91
3.1.1 Axioms 3.1.2 Single-Variable Theorems
3.1.3 Two- and Three-Variable Theorems 3.1.4 n-Variable Theorems
3.1.5 Duality 3.1.6 Standard Representations of Logic Functions
3.2 Combinational-Circuit Analysis 104
3.3 Combinational-Circuit Synthesis 110
3.3.1 Circuit Descriptions and Designs 3.3.2 Circuit Manipulations
3.3.3 Combinational-Circuit Minimization 3.3.4 Karnaugh Maps
3.4 Timing Hazards 122
3.4.1 Static Hazards 3.4.2 Finding Static Hazards Using Maps
3.4.3 Dynamic Hazards 3.4.4 Designing Hazard-Free Circuits
References 126
Drill Problems 128
Exercises 129
4 DIGITAL DESIGN PRACTICES 133
4.1 Documentation Standards 133
4.1.1 Block Diagrams 4.1.2 Gate Symbols
4.1.3 Signal Names and Active Levels 4.1.4 Active Levels for Pins
4.1.5 Constant Logic Signals 4.1.6 Bubble-to-Bubble Logic Design
4.1.7 Signal Naming in HDL Models 4.1.8 Drawing Layout
4.1.9 Buses 4.1.10 Additional Schematic Information
4.2 Circuit Timing 154
4.2.1 Timing Diagrams 4.2.2 Propagation Delay
4.2.3 Timing Specifications 4.2.4 Sample Timing Specifications
4.2.5 Timing Analysis Tools
4.3 HDL-Based Digital Design 165
4.3.1 HDL History 4.3.2 Why HDLs?
4.3.3 EDA Tool Suites for HDLs 4.3.4 HDL-Based Design Flow
References 172
Drill Problems 174
Exercises 176
5 VERILOG HARDWARE DESCRIPTION LANGUAGE 177
5.1 Verilog Models and Modules 179
5.2 Logic System, Nets, Variables, and Constants 184
5.3 Vectors and Operators 189
5.4 Arrays 193
5.5 Logical Operators and Expressions 194
5.6 Compiler Directives 197
5.7 Structural Models 198
5.8 Dataflow Models 203
5.9 Behavioral Models (Procedural Code) 205
5.9.1 Always Statements and Blocks 5.9.2 Procedural Statements
5.9.3 Inferred Latches 5.9.4 Assignment Statements
5.9.5 begin-end Blocks 5.9.6 if and if-else Statements
5.9.7 case Statements 5.9.8 Looping Statements
5.10 Functions and Tasks 220
5.11 The Time Dimension 224
5.12 Simulation 225
5.13 Test Benches 226
5.14 Verilog Features for Sequential Logic Design 232
5.15 Synthesis 232
References 233
Drill Problems 234
Exercises 235
6 BASIC COMBINATIONAL LOGIC ELEMENTS 237
6.1 Read-Only Memories (ROMs) 240
6.1.1 ROMs and Truth Tables
6.1.2 Using ROMs for Arbitrary Combinational Logic Functions
6.1.3 FPGA Lookup Tables (LUTs)
6.2 Combinational PLDs 246
6.2.1 Programmable Logic Arrays
6.2.2 Programmable Array Logic Devices
6.3 Decoding and Selecting 250
6.3.1 A More Mathy Decoder Definition 6.3.2 Binary Decoders
6.3.3 Larger Decoders 6.3.4 Decoders in Verilog
6.3.5 Custom Decoders 6.3.6 Seven-Segment Decoders
6.3.7 Binary Encoders
6.4 Multiplexing 281
6.4.1 Gate-Level Multiplexer Circuits 6.4.2 Expanding Multiplexers
6.4.3 Multiplexers, Demultiplexers, and Buses
6.4.4 Multiplexers in Verilog
References 294
Drill Problems 295
Exercises 296
7 MORE COMBINATIONAL BUILDING BLOCKS 301
7.1 Three-State Devices 302
7.1.1 Three-State Buffers 7.1.2 Standard MSI Three-State Buffers
7.1.3 Three-State Outputs in Verilog 7.1.4 Three-State Outputs in FPGAs
7.2 Priority Encoding 312
7.2.1 Cascading Priority Encoders 7.2.2 Priority Encoders in Verilog
7.3 Exclusive-OR Gates and Parity Functions 320
7.3.1 Exclusive-OR and Exclusive-NOR Gates
7.3.2 Parity Circuits 7.3.3 Parity-Checking Applications
7.3.4 Exclusive-OR Gates and Parity Circuits in Verilog
7.4 Comparing 331
7.4.1 Comparator Structure 7.4.2 Iterative Circuits
7.4.3 An Iterative Comparator Circuit 7.4.4 Magnitude Comparators
7.4.5 Comparators in HDLs 7.4.6 Comparators in Verilog
7.4.7 Comparator Test Benches
7.4.8 Comparing Comparator Performance
7.5 A Random-Logic Example in Verilog 356
Drill Problems 363
Exercises 364
8 COMBINATIONAL ARITHMETIC ELEMENTS 371
8.1 Adding and Subtracting 372
8.1.1 Half Adders and Full Adders 8.1.2 Ripple Adders
8.1.3 Subtractors 8.1.4 Carry-Lookahead Adders
8.1.5 Group Ripple Adders 8.1.6 Group-Carry Lookahead
8.1.7 MSI Arithmetic and Logic Units 8.1.8 Adders in Verilog
8.1.9 Parallel-Prefix Adders 8.1.10 FPGA CARRY4 Element
8.2 Shifting and Rotating 403
8.2.1 Barrel Shifters 8.2.2 Barrel Shifters in Verilog
8.3 Multiplying 416
8.3.1 Combinational Multiplier Structures 8.3.2 Multiplication in Verilog
8.4 Dividing 426
8.4.1 Basic Unsigned Binary Division Algorithm
8.4.2 Division in Verilog
References 433
Drill Problems 433
Exercises 434
9 STATE MACHINES 439
9.1 State-Machine Basics 440
9.2 State-Machine Structure and Analysis 443
9.2.1 State-Machine Structure 9.2.2 Output Logic
9.2.3 State-Machine Timing
9.2.4 Analysis of State Machines with D Flip-Flops
9.3 State-Machine Design with State Tables 455
9.3.1 State-Table Design Example 9.3.2 State Minimization
9.3.3 State Assignment 9.3.4 Synthesis Using D Flip-Flops
9.3.5 Beyond State Tables
9.4 State-Machine Design with State Diagrams 472
9.4.1 T-Bird Tail Lights Example
9.5 State-Machine Design with ASM Charts 478
9.5.1 T-Bird Tail Lights with ASM Charts
9.6 State-Machine Design with Verilog 483
References 486
Drill Problems 487
Exercises 490
10 SEQUENTIAL LOGIC ELEMENTS 495
10.1 Bistable Elements 496
10.1.1 Digital Analysis 10.1.2 Analog Analysis
10.1.3 Metastable Behavior
10.2 Latches and Flip-Flops 499
10.2.1 S-R Latch 10.2.2 S-R Latch
10.2.3 D Latch 10.2.4 Edge-Triggered D Flip-Flop
10.2.5 Edge-Triggered D Flip-Flop with Enable 10.2.6 T Flip-Flops
10.3 Latches and Flip-Flops in Verilog 508
10.3.1 Instance Statements and Library Components
10.3.2 Behavioral Latch and Flip-Flop Models
10.3.3 More about clocking in Verilog
10.4 Multibit Registers and Latches 522
10.4.1 MSI Registers and Latches
10.4.2 Multibit Registers and Latches in Verilog
10.5 Miscellaneous Latch and Bistable Applications 525
10.5.1 Switch Debouncing 10.5.2 Bus-Holder Circuits
10.6 Sequential PLDs 528
10.7 FPGA Sequential Logic Elements 531
10.8 Feedback Sequential Circuits 534
10.8.1 Basic Analysis
10.8.2 Analyzing Circuits with Multiple Feedback Loops
10.8.3 Feedback Sequential-Circuit Design
10.8.4 Feedback Sequential Circuits in Verilog
References 544
Drill Problems 545
Exercises 547
11 COUNTERS AND SHIFT REGISTERS 553
11.1 Counters 554
11.1.1 Ripple Counters 11.1.2 Synchronous Counters
11.1.3 A Universal 4-Bit Counter Circuit
11.1.4 Decoding Binary-Counter States
11.1.5 Counters in Verilog
xii Contents
11.2 Shift Registers 566
11.2.1 Shift-Register Structure 11.2.2 Shift-Register Counters
11.2.3 Ring Counters 11.2.4 Johnson Counters
11.2.5 Linear Feedback Shift-Register Counters
11.2.6 Shift Registers in Verilog 11.2.7 Timing-Generator Examples
11.2.8 LFSR Examples
11.3 Iterative versus Sequential Circuits 593
References 596
Drill Problems 596
Exercises 599
12 STATE MACHINES IN VERILOG 605
12.1 Verilog State-Machine Coding Styles 606
12.1.1 Basic Coding Style 12.1.2 A Verilog State-Machine Example
12.1.3 Combined State Memory and Next-State Logic 12.1.4 Reset Inputs
12.1.5 Pipelined Moore Outputs in Verilog
12.1.6 Direct Verilog Coding Without a State Table
12.1.7 State-Machine Extraction
12.2 Verilog State-Machine Test Benches 616
12.2.1 State-Machine Test-Bench Construction Methods
12.2.2 Example Test Benches
12.2.3 Instrumenting Next-State Logic for Testing
12.2.4 In Summary
12.3 Ones Counter 626
12.4 Combination Lock 628
12.5 T-Bird Tail Lights 632
12.6 Reinventing Traffic-Light Controllers 637
12.7 The Guessing Game 642
12.8 “Don’t-Care” State Encodings 646
12.9 Decomposing State Machines 648
12.9.1 The Guessing Game Again
12.10 The Trilogy Game 656
References 664
Drill Problems 664
Exercises 666
13 SEQUENTIAL-CIRCUIT DESIGN PRACTICES 673
13.1 Sequential-Circuit Documentation Practices 674
13.1.1 General Requirements 13.1.2 Logic Symbols
13.1.3 State-Machine Descriptions
13.1.4 Timing Diagrams and Specifications
13.2 Synchronous Design Methodology 681
13.2.1 Synchronous System Structure
13.2.2 A Synchronous System Design Example
13.3 Difficulties in Synchronous Design 691
13.3.1 Clock Skew 13.3.2 Gating the Clock
13.3.3 Asynchronous Inputs
Contents xiii
13.4 Synchronizer Failure and Metastability 701
13.4.1 Synchronizer Failure 13.4.2 Metastability Resolution Time
13.4.3 Reliable Synchronizer Design 13.4.4 Analysis of Metastable Timing
13.4.5 Better Synchronizers 13.4.6 Other Synchronizer Designs
13.5 Two-Clock Synchronization Example 710
References 729
Drill Problems 729
Exercises 730
14 DIGITAL CIRCUITS 733
14.1 CMOS Logic Circuits 735
14.1.1 CMOS Logic Levels 14.1.2 MOS Transistors
14.1.3 Basic CMOS Inverter Circuit
14.1.4 CMOS NAND and NOR Gates
14.1.5 Fan-In 14.1.6 Noninverting Gates
14.1.7 CMOS AND-OR-INVERT and OR-AND-INVERT Gates
14.2 Electrical Behavior of CMOS Circuits 745
14.2.1 Overview 14.2.2 Data Sheets and Specifications
14.3 CMOS Static Electrical Behavior 748
14.3.1 Logic Levels and Noise Margins
14.3.2 Circuit Behavior with Resistive Loads
14.3.3 Circuit Behavior with Nonideal Inputs 14.3.4 Fanout
14.3.5 Effects of Loading 14.3.6 Unused Inputs
14.3.7 How to Destroy a CMOS Device
14.4 CMOS Dynamic Electrical Behavior 764
14.4.1 Transition Time 14.4.2 Propagation Delay
14.4.3 Power Consumption
14.4.4 Current Spikes and Decoupling Capacitors
14.4.5 Inductive Effects
14.4.6 Simultaneous Switching and Ground Bounce
14.5 Other CMOS Input and Output Structures 778
14.5.1 Transmission Gates 14.5.2 Schmitt-Trigger Inputs
14.5.3 Three-State Outputs 14.5.4 Open-Drain Outputs
14.5.5 Driving LEDs and Relays 14.5.6 Multisource Buses
14.5.7 Wired Logic 14.5.8 Pull-Up Resistors
14.6 CMOS Logic Families 790
14.6.1 HC and HCT 14.6.2 AHC and AHCT
14.6.3 HC, HCT, AHC, and AHCT Electrical Characteristics
14.6.4 AC and ACT 14.6.5 FCT and FCT-T
14.7 Low-Voltage CMOS Logic and Interfacing 798
14.7.1 3.3-V LVTTL and LVCMOS Logic Levels 14.7.2 5-V Tolerant Inputs
14.7.3 5-V Tolerant Outputs 14.7.4 TTL/LVTTL Interfacing Summary
14.7.5 Logic Levels Less Than 3.3 V
14.8 Differential Signaling 803
References 804
Drill Problems 805
Exercises 808
xiv Contents
15 ROMS, RAMS, AND FPGAS 813
15.1 Read-Only Memory 814
15.1.1 Internal ROM Structure 15.1.2 Two-Dimensional Decoding
15.1.3 Commercial ROM Types 15.1.4 Parallel-ROM Interfaces
15.1.5 Parallel-ROM Timing
15.1.6 Byte-Serial Interfaces for NAND Flash Memories
15.1.7 NAND Memory Timing and Access Bandwidth
15.1.8 Storage Management for NAND Memories
15.2 Read/Write Memory 833
15.3 Static RAM 834
15.3.1 Static-RAM Inputs and Outputs
15.3.2 Static-RAM Internal Structure 15.3.3 Static-RAM Timing
15.3.4 Standard Asynchronous SRAMs 15.3.5 Synchronous SRAM
15.4 Dynamic RAM 844
15.4.1 Dynamic-RAM Structure 15.4.2 SDRAM Timing
15.4.3 DDR SDRAMs
15.5 Field-Programmable Gate Arrays (FPGAs) 851
15.5.1 Xilinx 7-Series FPGA Family
15.5.2 CLBs and Other Logic Resources 15.5.3 Input/Output Block
15.5.4 Programmable Interconnect
References 863
Drill Problems 864
Index 867
->**********************************15_Ghosh_en.txt
Analog and Digital Signals 1–4
Definitions
Difference between analog and digital signals
Advantage of Digital signal over analog signal.
2. Number Systems 5–18
Definitions
Radix representation of numbers
Conversion of one number system to the other (Decimal, Binary, Octal and Hexadecimal)
Fixed point representation
Floating point representation.
3. Logic Gates 19–34
Definitions
Basic Gates-NOT, OR, AND
Universal gates-NOR, NAND, X-OR gate
AND-OR-Invert gates
De-Morgan’s laws
Logic circuit for Boolean Expression and vice-versa
Positive logic and negative logic.
4. Combinational Logic Circuits and Simplification 35–54
Boolean laws and theorems
Consensus theorem
Karnaugh Map
Don’t care condition
Minterm and Maxterm
Simplification using
Boolean laws and theorems
Simplification using Karnaugh map for 3, 4 and 5 variables—SOP and POS
Simplification using tabular method
Simplification using Consensus theorem
Hazard and Hazard cover.
5. Binary Arithmetic 55–74
Binary addition, subtraction, multiplication, division
I’s complement
and 2’s complement
Half Adder
Full Adder
Half Subtractor
Full
Subtractor
Adder-Subtractor.
Detailed Contents
viii Digital Electronics
6. Codes and Parity 75–90
Weighted code-BCD code
Non weighted codes-Excess 3 code, Gray
code
Alpha numeric codes-ASCII, EBCDIC
Error detecting codes-
Odd parity, Even parity (Single and Double Error)
Error correcting or
Hamming code
Checksum code
CRC code.
7. Multiplexer, Demultiplexer, Encoder, Decoder 91–120
Definitions
Multiplexers
Demultiplexers
Implementation of logic
function using multiplexer
Decoder, BCD to decimal decoder
Seven
segment indicator
Encoder, decimal to BCD encoder.
8. Different Types of Displays 121–128
LED
LCD
Advantage and disadvantage
Difference between LED
ad LCD
Alpha numeric display-discrete method, bar-matrix method and
dot-matrix method.
9. Digital Logic Families 129–152
Bipolar Logic Family
Saturated-RTL, IIL, DTL, HTL and TTL
Non-Saturated Schottky TTL, ECL
Unipolar logic family-PMOS, NMOS and CMOS
SSI, MS LSI, VLSI
Characteristics of digital ICs.
10. Flip Flops 153–174
Definitions
RS Flip Flop
D Flip Flop
JK Flip Flop
T Flip Flop
Conversion of one Flip Flop to other
Finite state machine
Moore and
Mealy model
State graph and state tables.
11. Shift Registers 175–190
Definitions
Type of registers
Serial In-Serial Out
Serial In-Parallel
Out
Parallel In-Serial Out
Parallel In-Parallel Out
Universal shift
register
Ring counter.
12. Counters 191–214
Introduction
Types of counter
Asynchronous counter
Synchronous
counter
Difference between Asynchronous and Synchronous counter
Presettable counter
Design of counters for different modules
Design
of binary counters of random sequence using flip flop.
13. Semiconductor Memories 215–226
Definitions
Description RAM and ROM
Semiconductor memory
organization
Classification
Expansion of word length and word
capacity
Difference between Static RAM and Dynamic RAM.
14. D/A Conversion and A/D Conversion 227–250
D/A Converter
Binary equivalent rate
Binary Ladder
A/D Converter
Simultaneous, Counter Type, Continuous A/D converter, successive
approximation method, single slope and dual slope A/D converter.
->**********************************16_Raychaudhuri_en.txt
Preface xvii
Chapter 1. Origin of Electronics 1
1.1 What is Electronics 1
1.2 Evolution of Electronics 2
1.2.1 Revisiting the History 2
1.2.2 Trends of Development 4
1.3 Widespread Applications 5
1.4 Electrons, Electricity and Electronics 6
1.4.1 Electric Current 7
1.4.2 Drift Velocity, Mobility and Conductivity 8
1.4.3 Electron Emission from Metal 10
1.5 Circuits and Sources 11
1.5.1 Types of Circuits 11
1.5.2 Voltage and Current Sources 12
1.6 Active and Passive Device 14
Multiple Choice-Type Questions and Answers 15
Reasoning-Type Questions and Answers 16
Solved Numerical Problems 16
Exercise 18
Chapter 2. Semiconductor Fundamentals 20
2.1 Crystalline Solids 20
2.1.1 Lattice, Basis and Unit Cell 21
2.1.2 Bravais Lattice and Miller Indices 22
2.2 Energy Band 24
2.3 Semiconductors 26
2.3.1 Electron and Hole 27
2.3.2 Intrinsic Semiconductor 29
2.3.3 Doping and Extrinsic Semiconductor 30
2.3.4 Doping in Compound Semiconductor 32
2.4 Direct and Indirect Band Gap 32
2.5 Effective Mass 33
2.6 Fermi Level, Energy Band and Semiconductors 35
2.6.1 Energy Band of n-type Semiconductors 38
2.6.2 Energy Band of p-type Semiconductors 39
2.7 Equilibrium Carrier Concentrations 40
2.8 Drift and Diffusion of Carriers 43
2.8.1 Drift Current Density 44
2.8.2 Diffusion Current Density 45
2.8.3 Semiconductor Current Density 45
2.8.4 Einstein Relation 46
2.8.5 Continuity Equation 47
2.9 Hall Effect 48
2.10 Resistivity and Four-Probe Technique 49
Multiple Choice-Type Questions and Answers 50
Reasoning-Type Questions and Answers 53
Solved Numerical Problems 55
Exercise 57
Project Work on Chapter 2 60
Chapter 3. p–n Junction Diodes 61
3.1 Fabrication of p–n Junction 61
3.2 Barrier Formation in p–n Junction 62
3.2.1 Built-in Potential 64
3.2.2 Fermi Level in p–n Junction 65
3.2.3 Energy Band Diagram of p–n Junction 66
3.3 Forward and Reverse Bias 67
3.3.1 Unbiased Diode 68
3.3.2 Forward Biased Diode 69
3.3.3 Reverse Biased Diode 69
3.4 Diode Current–voltage Characteristics 70
3.4.1 Static and Dynamic Resistance 72
3.4.2 Cut-in Voltage 74
3.5 Junction Capacitances 74
3.5.1 Depletion Capacitance 74
3.5.2 Diffusion Capacitance 75
3.6 Zener Diode 76
3.6.1 Zener Breakdown 76
3.6.2 Avalanche Breakdown 77
3.6.3 Zener Diode Characteristics 79
3.6.4 Zener Voltage Regulator 80
3.7 Light-Emitting Diode (LED) 82
3.8 Photodiode and Solar Cell 84
3.9 Metal–Semiconductor Contacts 86
Multiple Choice-Type Questions and Answers 87
Reasoning-Type Questions and Answers 91
Solved Numerical Problems 92
Exercise 95
Project Work on Chapter 3 99
Chapter 4. Diode Applications 101
4.1 Piecewise Linear Model 101
4.2 Load Line and Q-Point 102
4.3 Rectifiers 104
4.3.1 Half-Wave Rectifier 105
4.3.2 Full-Wave Rectifier 111
4.3.3 Bridge Rectifier 114
4.4 Filters 117
4.4.1 Capacitor Filter 117
4.4.2 Inductor Filter 119
4.5 Clippers 120
4.5.1 Shunt Clipper 120
4.5.2 Series Clipper 120
4.6 Clamper 123
4.7 Voltage Multiplier 125
Multiple Choice-Type Questions and Answers 127
Reasoning-Type Questions and Answers 131
Solved Numerical Problems 132
Exercise 134
Project Work on Chapter 4 138
Chapter 5. Bipolar Junction Transistor (BJT) 141
5.1 Transistors: n–p–n and p–n–p 141
5.2 Transistor Operating Principle 142
5.3 Common-Emitter Configuration 143
5.3.1 Current Amplification in Transistor 144
5.3.2 Transistor Current Components 145
5.3.3 Common-Emitter Output Characteristics 148
5.3.4 Early Effect 150
5.3.5 CE Input Characteristics 150
5.3.6 CE Transfer Characteristics 150
5.4 Common-Base Characteristics 151
5.5 Common-Collector Configuration
Multiple Choice-Type Questions and Answers 155
Reasoning-Type Questions and Answers 157
Solved Numerical Problems 159
Exercise 160
Project Work on Chapter 5 161
Chapter 6. Transistor Biasing and Amplification 163
6.1 Load Line and Q-Point 163
6.2 Transistor Biasing and Stability 165
6.3 Base Bias 167
6.4 Emitter–Feedback Bias 169
6.5 Collector–Feedback Bias 171
6.6 Voltage-Divider Bias 172
6.7 Load: DC and AC 175
6.8 BJT Small Signal Voltage Amplifiers 177
6.8.1 Common-Emitter (CE) Amplifier 178
6.8.2 Common-Collector (CC) Amplifier 182
6.8.3 Common-Base (CB) Amplifier 184
Multiple Choice-type Questions and Answers 186
Reasoning-Type Questions and Answers 188
Solved Numerical Problems 189
Exercise 194
Project Work on Chapter 6 197
Chapter 7. Network Theorems and Transistor 200
7.1 Thevenin’s Theorem 200
7.2 Norton’s Theorem 202
7.3 Other Useful Theorems 203
7.3.1 Superposition Theorem 203
7.3.2 Maximum Power Transfer Theorem 204
7.4 Two-Port Model and Hybrid Parameters 205
7.4.1 Transistor as Two-port Network 207
7.4.2 Significance of h Parameters 209
7.5 Transistor Amplifier with h Parameters 211
7.6 Simplified Hybrid Model 214
7.7 re-Model and h-Model 215
7.8 Transistor: Thevenin and Norton Equivalents 216
7.9 Frequency Dependence of Gain 219
7.10 Hybrid-Π Model 221
7.11 Transistor Gain at High Frequency 224
7.12 Gain and Decibel 227
Multiple Choice-Type Questions and Answers 155
Reasoning-Type Questions and Answers 157
Solved Numerical Problems 159
Exercise 160
Project Work on Chapter 5 161
Chapter 6. Transistor Biasing and Amplification 163
6.1 Load Line and Q-Point 163
6.2 Transistor Biasing and Stability 165
6.3 Base Bias 167
6.4 Emitter–Feedback Bias 169
6.5 Collector–Feedback Bias 171
6.6 Voltage-Divider Bias 172
6.7 Load: DC and AC 175
6.8 BJT Small Signal Voltage Amplifiers 177
6.8.1 Common-Emitter (CE) Amplifier 178
6.8.2 Common-Collector (CC) Amplifier 182
6.8.3 Common-Base (CB) Amplifier 184
Multiple Choice-type Questions and Answers 186
Reasoning-Type Questions and Answers 188
Solved Numerical Problems 189
Exercise 194
Project Work on Chapter 6 197
Chapter 7. Network Theorems and Transistor 200
7.1 Thevenin’s Theorem 200
7.2 Norton’s Theorem 202
7.3 Other Useful Theorems 203
7.3.1 Superposition Theorem 203
7.3.2 Maximum Power Transfer Theorem 204
7.4 Two-Port Model and Hybrid Parameters 205
7.4.1 Transistor as Two-port Network 207
7.4.2 Significance of h Parameters 209
7.5 Transistor Amplifier with h Parameters 211
7.6 Simplified Hybrid Model 214
7.7 re-Model and h-Model 215
7.8 Transistor: Thevenin and Norton Equivalents 216
7.9 Frequency Dependence of Gain 219
7.10 Hybrid-Π Model 221
7.11 Transistor Gain at High Frequency 224
7.12 Gain and Decibel 227
9.6 FET Model 293
9.7 FET Biasing 294
9.7.1 Self-Bias 294
9.7.2 Drain-Feedback Bias 296
9.7.3 Gate Bias 297
9.7.4 Voltage-Divider Bias 298
9.8 FET Amplifiers 300
9.8.1 Common-Source (CS) Amplifier 300
9.8.2 Common-Drain (CD) Amplifier 301
9.8.3 Common-Gate (CG) Amplifier 302
Multiple Choice-Type Questions and Answers 304
Reasoning-Type Questions and Answers 306
Solved Numerical Problems 307
Exercise 308
Project Work on Chapter 9 310
Chapter 10. Feedback Amplifiers and Oscillators 313
10.1 Concept of Feedback 313
10.2 Types of Feedback 316
10.2.1 Voltage–series Feedback 317
10.2.2 Voltage–shunt Feedback 318
10.2.3 Current–series Feedback 319
10.2.4 Current–shunt Feedback 320
10.3 Advantages of Negative Feedback 321
10.3.1 Stability Improvement 322
10.3.2 Impedance Improvement 322
10.3.3 Bandwidth Enhancement 324
10.3.4 Noise Reduction 326
10.3.5 Reduction of Nonlinear Distortion 326
10.4 Oscillators 327
10.4.1 Positive Feedback and Oscillation 328
10.4.2 Resonant Circuit Oscillators 329
10.4.3 Colpitts Oscillator 331
10.4.4 Hartley Oscillator 332
10.4.5 Wien Bridge Oscillator 333
10.4.6 Phase-Shift Oscillator 338
10.4.7 Crystal Oscillator 341
10.5 Multivibrators 345
10.5.1 Astable Multivibrator 345
10.5.2 Monostable Multivibrator 348
Multiple Choice-Type Questions and Answers 350
Reasoning-Type Questions and Answers 352
Solved Numerical Problems 353
Exercise 357
Project Work on Chapter 10 359
Chapter 11. Operational Amplifier 362
11.1 A Review on Amplifiers 362
11.2 Features of Op-Amp 363
11.3 Differential Amplifier 365
11.4 Common Mode Rejection Ratio 368
11.5 Diff-Amp to Op-Amp 369
11.6 Offset Parameters 370
11.7 Slew Rate 373
11.8 Linear Op-Amp Circuits 374
11.8.1 Inverting Amplifier 375
11.8.2 Noninverting Amplifier 377
11.8.3 Virtual Short and Virtual Ground 382
11.8.4 Voltage Follower 383
11.8.5 Op-Amp Adder (Inverting) 384
11.8.6 Op-Amp Adder (Noninverting) 385
11.8.7 Differential Amplifier 386
11.8.8 Instrumentation Amplifier 388
11.8.9 Passive and Active Filters 389
11.8.10 Active Low-Pass Filter 392
11.8.11 Active High-Pass Filter 394
11.8.12 Active Band-Pass and Band-Stop Filters 395
11.9 Nonlinear Op-Amp Circuits 396
11.9.1 Integrator 396
11.9.2 Differentiator 398
11.9.3 Comparator 400
11.9.4 Schmitt Trigger 401
11.9.5 Logarithmic Amplifier 402
11.9.6 Solving Algebraic Equation 403
11.9.7 Solving Differential Equation 404
11.9.8 Precision Rectifier 405
11.10 Op-Amp Waveform Generators 406
11.10.1 Square Wave Generator 406
11.10.2 Triangular Wave Generator 407
11.10.3 Sine Wave Generator
Multiple Choice-Type Questions and Answers 409
Reasoning-Type Questions and Answers 414
Solved Numerical Problems 415
Exercise 422
Projects on Chapter 11 428
Chapter 12. IC Technology and Instrumentation 432
12.1 Integrated Circuit (IC) 432
12.2 IC Classification 433
12.3 IC Fabrication 436
12.4 IC Components: Active and Passive 437
12.5 Regulated Power Supply 439
12.6 Cathode Ray Oscilloscope (CRO) 442
12.6.1 Construction of CRO 444
12.6.2 Working Principle 445
12.6.3 Electrostatic Focusing 446
12.6.4 Electrostatic Deflection 447
12.6.5 Waveform Display 449
12.6.6 Applications of CRO 451
12.7 Digital Storage Oscilloscope 454
Multiple Choice-Type Questions and Answers 456
Reasoning-Type Questions and Answers 457
Solved Numerical/Analytic Problems 458
Exercise 459
Chapter 13. Digital Principles and Boolean Algebra 460
13.1 The Digital System 460
13.1.1 Analog and Digital 460
13.1.2 Pros and Cons of Digital System 461
13.2 Number Systems and Conversions 462
13.2.1 Binary Numbers 463
13.2.2 Binary to Decimal Conversion 464
13.2.3 Decimal to Binary Conversion 464
13.2.4 Octal Numbers 467
13.2.5 Hexadecimal Numbers 469
13.3 Digital Codes 470
13.4 Binary Arithmetic 472
13.4.1 1’s Complement and 2’s Complement 473
13.4.2 Radix Complements 477
13.4.3 Signed Binary Numbers 478
13.5 Boolean Algebra 479
13.5.1 OR Operation 482
13.5.2 AND Operation 483
13.5.3 NOT Operation 483
13.5.4 De Morgan’s Theorems 484
13.6 Boolean Simplification 485
13.7 Sum-of-Products and Product-of-Sums 488
13.7.1 Sum-of-Products (SOP) 488
13.7.2 Product-of-Sums (POS) 490
13.8 Karnaugh Map 493
13.8.1 Don’t Care Conditions 498
13.8.2 Simplification is not Unique 499
13.8.3 SOP and POS are Equivalent 499
Multiple Choice-Type Questions and Answers 500
Reasoning-Type Questions and Answers 503
Solved Numerical and Logical Problems 503
Exercise 507
Projects on Chapter 13 508
Chapter 14. Combinational Logic Circuits 510
14.1 Boolean Algebra and Digital Electronics 510
14.1.1 Combinational and Sequential Logic 511
14.1.2 Positive and Negative Logic 512
14.2 Logic Gates 513
14.2.1 OR Gate 513
14.2.2 AND Gate 513
14.2.3 NOT Gate 515
14.2.4 NOR Gate (Universal Gate) 516
14.2.5 NAND Gate (Universal Gate) 517
14.2.6 Bubbled Gates 518
14.2.7 Exclusive-OR (XOR) Gate 519
14.2.8 Timing Diagram 522
14.3 Logic Families 522
14.3.1 Transistor–Transistor Logic (TTL) 523
14.3.2 MOS Logic 525
14.4 Arithmetic and Logic Circuits 527
14.4.1 Half Adder 527
14.4.2 Full Adder 528
14.4.3 Half and Full Subtractors 530
14.4.4 Adder–Subtractor 531
14.4.5 Digital Comparators
14.5 Data Processing Circuits 533
14.5.1 Multiplexer 533
14.5.2 Demultiplexer 536
14.5.3 Decoders 536
14.5.4 Seven-Segment Display 537
14.5.5 Encoders 540
14.5.6 Parity Checker and Generator 541
Multiple Choice-Type Questions and Answers 542
Reasoning-Type Questions and Answers 546
Solved Logical Problems 547
Exercise 552
Project Work on Chapter 14 555
Chapter 15. Sequential Logic Circuits 557
15.1 Clock and Timer 557
15.1.1 Clock Parameters 558
15.1.2 Working Principles of IC 555 559
15.1.3 Astable Multivibrator with IC 555 560
15.1.4 Monostable Multivibrator with IC 555 562
15.2 Latch and Flip-Flop 563
15.2.1 Bistable Multivibrator 564
15.2.2 RS Flip-Flop with NOR Gates 565
15.2.3 RS Flip-Flop with NAND Gates 567
15.2.4 Clocked RS Flip-Flop 569
15.2.5 D Flip-Flop 570
15.2.6 JK Flip-Flop 571
15.2.7 Racing and Propagation Delay 572
15.2.8 Edge- and Pulse-Triggering 573
15.2.9 JK Master–Slave Flip-Flop 575
15.2.10 T Flip-Flop 577
15.3 Flip-Flop Characterization 578
15.3.1 Characteristic Equation 579
15.3.2 State Diagram 579
15.3.3 Preset and Clear 580
15.4 Register 581
15.4.1 Register with Series and Parallel Shifting 583
15.4.2 Ring Counter 586
15.4.3 Johnson Counter 587
15.4.4 Register Applications 588
15.5 Counters 588
15.5.1 Asynchronous Counter 589
15.5.2 Synchronous Counter 591
15.6 Changing Counter Modulus 592
15.6.1 Mod-3 Counter 593
15.6.2 Mod-6 Counter 593
15.6.3 Mod-5 Counter 594
15.6.4 Decade (Mod-10) Counter 595
15.6.5 Decade Counter using Preset-Clear 596
15.6.6 Applications of the Counter 598
Multiple Choice-Type Questions and Answers 598
Reasoning-Type Questions and Answers 600
Solved Numerical Problems 602
Exercise 604
Chapter 16. Analog–Digital Conversion and Memory 609
16.1 Why D/A and A/D Conversions 609
16.2 Binary Equivalent Weight 610
16.3 Digital-to-Analog (D/A) Conversion 611
16.3.1 Weighted Resistor D/A Converter 611
16.3.2 R-2R ladder D/A Converter 614
16.3.3 D/A Converter Performance 617
16.4 Analog-to-Digital (A/D) Conversion 618
16.4.1 Flash A/D Converter 618
16.4.2 Counter-Type A/D Converter 620
16.4.3 Successive-Approximation A/D Converter 622
16.5 Memory 622
16.5.1 Read-Only Memory (ROM) 625
16.5.2 Random Access Memory (RAM) 627
16.5.3 Memory Addressing 629
16.5.4 Memory Read/Write 630
Multiple Choice-Type Questions and Answers 631
Reasoning-Type Questions and Answers 633
Solved Numerical Problems 633
Exercise 634
Project Work on Chapter 16 635
Chapter 17. Microcomputer and Microprocessor 637
17.1 Evolution of Computer 637
17.1.1 Historical Background 637
17.1.2 Modern Computer 639
17.2 Computer, Microprocessor and Microcontroller 641
17.2.1 Computer Organization 641
17.2.2 Use of Microprocessor 643
17.2.3 Use of Microcontroller 644
15.6 Changing Counter Modulus 592
15.6.1 Mod-3 Counter 593
15.6.2 Mod-6 Counter 593
15.6.3 Mod-5 Counter 594
15.6.4 Decade (Mod-10) Counter 595
15.6.5 Decade Counter using Preset-Clear 596
15.6.6 Applications of the Counter 598
Multiple Choice-Type Questions and Answers 598
Reasoning-Type Questions and Answers 600
Solved Numerical Problems 602
Exercise 604
Chapter 16. Analog–Digital Conversion and Memory 609
16.1 Why D/A and A/D Conversions 609
16.2 Binary Equivalent Weight 610
16.3 Digital-to-Analog (D/A) Conversion 611
16.3.1 Weighted Resistor D/A Converter 611
16.3.2 R-2R ladder D/A Converter 614
16.3.3 D/A Converter Performance 617
16.4 Analog-to-Digital (A/D) Conversion 618
16.4.1 Flash A/D Converter 618
16.4.2 Counter-Type A/D Converter 620
16.4.3 Successive-Approximation A/D Converter 622
16.5 Memory 622
16.5.1 Read-Only Memory (ROM) 625
16.5.2 Random Access Memory (RAM) 627
16.5.3 Memory Addressing 629
16.5.4 Memory Read/Write 630
Multiple Choice-Type Questions and Answers 631
Reasoning-Type Questions and Answers 633
Solved Numerical Problems 633
Exercise 634
Project Work on Chapter 16 635
Chapter 17. Microcomputer and Microprocessor 637
17.1 Evolution of Computer 637
17.1.1 Historical Background 637
17.1.2 Modern Computer 639
17.2 Computer, Microprocessor and Microcontroller 641
17.2.1 Computer Organization 641
17.2.2 Use of Microprocessor 643
17.2.3 Use of Microcontroller 644
->**********************************17_War_en.txt
Chapter 1:​ Introduction to Logic Gates
Integrated Circuits, or ICs
Gate Technology
The Main Differences Between TTL and CMOS
Logic Families
Fan-Out and Fan-In
Unused Inputs
Handling Logic ICs
The Historical Circuits of the Logic Gates
The Laws of Logic
Diode-Resistor (DR) Logic
Analysis of Diode-Resistor Circuit 1
Analysis of Diode-Resistor Circuit 2
Analysis of Circuit 3
The “4000” Series
The PLA, or Programmable Logic Array
The Binary Number System
Binary Numbers
Converting from Decimal to Binary
Converting from Binary to Decimal
Exercise 1
Adding and Subtracting Binary Numbers
Worked Example
Exercise 2
Subtracting Binary Numbers
Worked Example
Exercise 3
The Logic Gates
The AND Gate
The NAND Gate
The OR Gate
The NOR Gate
The EXOR Gate
The NOT Gate or Inverter
Summary
Chapter 2:​ Boolean Algebra
What Is Boolean Algebra
The Basic Concept
The NOT Gate
The AND and NAND Gates
The OR and NOR Gates
The Exclusive OR Gate, That Is, the EXOR Gate
Deriving Boolean Expressions from Logic Circuits
Boolean Derivation Circuit 1
Boolean Derivation Circuit 2
Boolean Derivation Circuit 3
Building Logic Circuits from Boolean Expressions
Build Logic Circuit Example 1
Build Logic Circuit Example 2
Build Logic Circuit Example 3
Exercise 1
Exercise 2
The Laws of Boolean Algebra
Commutative Law
Commutative Example 1
Commutative Example 2
Associative Law
Associative Law Example 1
Associative Law Example 2
Distributive Law
Distributive Law Example 1
Distributive Law Example 2
Distribution Law Example 3
Absorption Law
De Morgan’s Theory
De Morgan’s Example 1
De Morgan’s Example 2
De Morgan’s Examples 3
The OR Function with NAND Gates
Summary
Chapter 3:​ Simplifying Boolean Expressions
Some Fundamental Identities
The Inverse Law
The Identity Law
The Null Law
The Idempotent Law
The OR Version of the Idempotent Law
The OR Version of the Identity Law
The OR Version of the Null Law
The OR Version of the Inverse Law
Using Boolean Algebra to Minimize Expressions
Simplification Example 1
Simplification Example 2
Simplification Example 3
Simplification Example 4
Simplification Example 5
Simplification Example 6
Karnaugh Maps
Karnaugh Map Example 1
Using the Karnaugh Map
Karnaugh Map Example 2
Simplification Examples
Simplification Example 7
The 1st and 2nd Canonical Formats and the Minterms and Maxterms
The 2nd Canonical Format
Simplification Example 8
Simplification Example 9
Simplification Example 10
Simplification Example 11
Summary
Chapter 4:​ Moving On from the NAND Gate
The SR Latch
The De-bounce Circuit
The Basic SR Latch with NOR Gates
The Indeterminate State
The Clocked $$ \overline{S}\kern0.5em \overline{R}\kern0.5em \mathrm{Latch} $$
The Master-Slave Clocked SR
The JK Flip Flop
Using the JK Flip Flop
The D-Type Latch
The T Latch
The Main Configurations for the JK Flip Flop
The JK Flip Flop
Summary
Chapter 5:​ Design Methods for Digital Circuits
Combinational and Sequential Logic
Combinational Logic
Sequential Logic
Representing a Digital System
Asynchronous and Synchronous Logic Systems
The Ripple Counter
Design Example 1:​ The Modulo 10 Counter
Design Example 2:​ A Non-sequential Output
Design Example 3:​ A Synchronized Sequential Circuit
Exercise 5.​1
Design Example 4:​ A Synchronized Up Counter
Exercise 5.​2
Design Example 5:​ A Modulo 6 Binary Counter
Determining the Inputs for the Three D-Type Latches
The D0 Inputs
The D1 Inputs
The D2 Inputs
Synopsis
Chapter 6:​ State Example 3 A Bit Stream Monitor
State Diagrams
The State Diagram of the JK Flip Flop
Creating the JK Flip Flop State Table
Methodology for Designing Sequential Digital Logic Circuits
State Diagram Example 1:​ The Synchronized Binary Counter
Determining the Inputs for the Four D-Type Latches
The D0 Input
Exercise 1
The D1 Input
The D2 Input
Exercise 2
State Diagram Example 2:​ The Design of a Modulo 10 Binary Counter Using State Diagrams
The State Table
Determining the Inputs for the Four D-Type Latches
The D0 Input
The D1 Input
Exercise 3
State Diagram Example 3:​ A Bit Stream Monitor
The D0 Inputs
The D1 Expression
State Diagram Example 4
The D0 Expression
Exercise 4
Moore’s and Mealy Diagrams
Summary
Chapter 7:​ Combinational Logic
The Tri-state Buffer
The Half Adder Circuit
The Design of the Full Adder Circuit
Exercise 1
A 3-Bit Full Adder
The Binary Subtractor Circuit
An Alternative Subtractor Circuit
Subtracting by Adding Decimal Numbers
A 4-Bit Multiplexer
A Demultiplexer
Digital Encoders
Application of Digital Encoders
The Digital Decoder
A Seven-Segment Decoder Chip
The Seven-Segment Display
Common Anode Seven-Segment Display
Common Cathode Seven-Segment Display
Exercise 2
Summary
Chapter 8:​ Shift Registers and More
The D-Type Latch
The 4-Bit Shift Register or SISO (Serial In Serial Out)
The PISO (Parallel In Serial Out) Register
The PIPO (Parallel In Parallel Out) Register
The SIPO (Serial In Parallel Out)
The Ring Counter
The Johnson Ring Counter
A Frequency Divider
The Divide by 4 Johnson Ring Counter
The Phase Shift Across the Latches
Summary
Chapter 9:​ Designing Some Useful Logic Circuits
Example 1:​ A Design Process for a Single Set of Traffic Lights
Analysis of the Output Logic
Example 2:​ An Alternative Single Set of Traffic Lights
Example 3:​ Adding a Pelican Crossing
An Egg Timer Circuit
The SN74168
The Practical IC We Have Looked At
The 7400 Quad-Two-Input NAND Gate
Counters
The 7493 Binary Counter
The SN74194 Multifunction Shift Register
Summary
Chapter 10:​ Introduction to the 555 Timer
The 555 Timer
The Pins of the 555 Timer
The Timer Used as a Monostable
The Basic Astable
Creating a 50/​50 Duty Cycle Square Wave
Creating a 1Hz Square Wave
A PWM Application
Summary
Chapter 11:​ Using TINA 12
What Is ECAD and TINA 12
Running the Software
Creating Our First Test Circuit
Using a Binary Counter
Using Jumper Terminals
Creating a Macro for the 7400 IC, a Quad-Two-I/​P NAND Gate
Using the Quad NAND 7400 Macro
Summary
Appendix:​ Appendix 1
Appendix 2:​ Solutions for Exercises in the Chapters
Appendix:​ Exercises
Index
->**********************************18_Tokheim_en.txt
Preface ix
Acknowledgments x
Walkthrough xii
About the Author xiv
Safety xv
Chapter 1 Digital Electronics 1
1-1What Is a Digital Signal? 2
1-2Why Use Digital Circuits? 4
1-3Where Are Digital Circuits Used? 8
1-4How Do You Generate a Digital Signal? 9
1-5How Do You Test for a Digital Signal? 15
1-6Simple Instruments 19
Summary 22
Correlated Experiments 22
Chapter Review Questions 22
Critical Thinking Questions 24
Answers to Self-Tests 25
Chapter 2 Numbers We Use in Digital Electronics 26
2-1Counting in Decimal and Binary 26
2-2Place Value 27
2-3Binary to Decimal Conversion 29
2-4Decimal to Binary Conversion 30
2-5Electronic Translators 31
2-6Hexadecimal Numbers 34
2-7Octal Numbers 36
2-8Bits, Bytes, Nibbles, and Word Size 37
Summary 39
Correlated Experiments 39
Chapter Review Questions 39
Critical Thinking Questions 40
Answers to Self-Tests 42
Chapter 3 Logic Gates 43
3-1The AND Gate 43
3-2The OR Gate 46
3-3The Inverter and Buffer 48
3-4The NAND Gate 50
3-5The NOR Gate 51
3-6The Exclusive OR Gate 53
3-7The Exclusive NOR Gate 54
3-8The NAND Gate as a Universal Gate 56
The NOR Gate as a Universal Gate 59
3-10Gates with More Than Two Inputs 63
3-11Using Inverters to Convert Gates 65
3-12Practical TTL Logic Gates 68
3-13Practical CMOS Logic Gates 71
3-14Troubleshooting Simple Gate Circuits 75
3-15IEEE Logic Symbols 77
3-16Simple Logic Gate Applications 79
3-17Logic Functions Using Software (BASIC Stamp Module) 83
Summary 88
Correlated Experiments 89
Chapter Review Questions 89
Critical Thinking Questions 92
Answers to Self-Tests 95
Chapter 4 Combining Logic Gates 96
4-1Constructing Circuits from Boolean Expressions 97
4-2Drawing a Circuit from a Maxterm Boolean Expression 98
4-3Truth Tables and Boolean Expressions 99
4-4Sample Problem 103
4-5Simplifying Boolean Expressions 105
4-6Boolean Algebra 106
4-7Karnaugh Maps 114
4-8Karnaugh Maps with Three Variables 115
4-9Karnaugh Maps with Four Variables 117
4-10More Karnaugh Maps 118
4-11A Five-Variable Karnaugh Map 119
4-12Using NAND Logic 120
4-13Computer Simulations: Logic Converter 122
4-14Solving Logic Problems: Data Selectors 126
4-15Programmable Logic Devices (PLDs) 130
4-16Using De Morgan’s Theorems 138
page vi
4-17Solving a Logic Problem (BASIC Stamp Module) 140
Summary 145
Correlated Experiments 146
Chapter Review Questions 146
Critical Thinking Questions 150
Answers to Self-Tests 150
Chapter 5 IC Specifications and Simple Interfacing 155
5-1Logic Levels and Noise Margin 155
5-2Other Digital IC Specifications 160
5-3MOS and CMOS ICs 165
5-4Interfacing TTL and CMOS with Switches 167
5-5Interfacing TTL and CMOS with LEDs 171
5-6Interfacing TTL and CMOS ICs 175
5-7Interfacing with Buzzers, Relays, Motors, and Solenoids 179
5-8Optoisolators 182
The NOR Gate as a Universal Gate 59
3-10Gates with More Than Two Inputs 63
3-11Using Inverters to Convert Gates 65
3-12Practical TTL Logic Gates 68
3-13Practical CMOS Logic Gates 71
3-14Troubleshooting Simple Gate Circuits 75
3-15IEEE Logic Symbols 77
3-16Simple Logic Gate Applications 79
3-17Logic Functions Using Software (BASIC Stamp Module) 83
Summary 88
Correlated Experiments 89
Chapter Review Questions 89
Critical Thinking Questions 92
Answers to Self-Tests 95
Chapter 4 Combining Logic Gates 96
4-1Constructing Circuits from Boolean Expressions 97
4-2Drawing a Circuit from a Maxterm Boolean Expression 98
4-3Truth Tables and Boolean Expressions 99
4-4Sample Problem 103
4-5Simplifying Boolean Expressions 105
4-6Boolean Algebra 106
4-7Karnaugh Maps 114
4-8Karnaugh Maps with Three Variables 115
4-9Karnaugh Maps with Four Variables 117
4-10More Karnaugh Maps 118
4-11A Five-Variable Karnaugh Map 119
4-12Using NAND Logic 120
4-13Computer Simulations: Logic Converter 122
4-14Solving Logic Problems: Data Selectors 126
4-15Programmable Logic Devices (PLDs) 130
4-16Using De Morgan’s Theorems 138
page vi
4-17Solving a Logic Problem (BASIC Stamp Module) 140
Summary 145
Correlated Experiments 146
Chapter Review Questions 146
Critical Thinking Questions 150
Answers to Self-Tests 150
Chapter 5 IC Specifications and Simple Interfacing 155
5-1Logic Levels and Noise Margin 155
5-2Other Digital IC Specifications 160
5-3MOS and CMOS ICs 165
5-4Interfacing TTL and CMOS with Switches 167
5-5Interfacing TTL and CMOS with LEDs 171
5-6Interfacing TTL and CMOS ICs 175
5-7Interfacing with Buzzers, Relays, Motors, and Solenoids 179
5-8Optoisolators 182
5-9Interfacing with Servo and Stepper Motors 185
5-10Using Hall-Effect Sensors 193
5-11Troubleshooting Simple Logic Circuits 200
5-12Interfacing the Servo (BASIC Stamp Module) 201
Summary 204
Correlated Experiments 205
Chapter Review Questions 205
Critical Thinking Questions 209
Answers to Self-Tests 210
Chapter 6 Encoding, Decoding, and Seven-Segment Displays 212
6-1The 8421 BCD Code 212
6-2The Excess-3 Code 214
6-3The Gray Code 215
6-4The ASCII Code 218
6-5Encoders 219
6-6Seven-Segment LED Displays 221
6-7Decoders 224
6-8BCD-to-Seven-Segment Decoder/Drivers 225
6-9Liquid-Crystal Displays 229
6-10Using CMOS to Drive an LCD Display 234
6-11Vacuum Fluorescent Displays 237
6-12Driving a VF Display 240
6-13Troubleshooting a Decoding Circuit 243
Summary 245
Correlated Experiments 246
Chapter Review Questions 246
Critical Thinking Questions 249
Answers to Self-Tests 250
Chapter 7 Flip-Flops 252
7-1The R-S Flip-Flop 252
7-2The Clocked R-S Flip-Flop 255
7-3The D Flip-Flop 257
7-4The J-K Flip-Flop 259
7-5IC Latches 263
7-6Triggering Flip-Flops 265
7-7Schmitt Trigger 267
7-8IEEE Logic Symbols 268
7-9Application: Latched Encoder-Decoder System 270
Summary 273
Correlated Experiments 274
Chapter Review Questions 274
Critical Thinking Questions 275
Answers to Self-Tests 276
Chapter 8 Counters 278
8-1Ripple Counters 278
Mod-10 Ripple Counters 281
8-3Synchronous Counters 282
8-4Down Counters 283
8-5Self-Stopping Counters 285
8-6Counters as Frequency Dividers 286
8-7TTL IC Counters 288
8-8CMOS IC Counters 292
8-9A Three-Digit BCD Counter 296
8-10Counting Real-World Events 300
8-11Using a CMOS Counter in an Electronic Game 304
8-12Using Counters—An Experimental Tachometer 307
8-13Troubleshooting a Counter 311
Summary 314
Correlated Experiments 314
Chapter Review Questions 315
Critical Thinking Questions 318
Answers to Self-Tests 319
page vii
Chapter 9 Shift Registers 321
9-1Serial-Load Shift Registers 323
9-2Parallel-Load Shift Registers 324
9-3A Universal Shift Register 327
9-4Using the 74LS194 IC Shift Register 329
9-5An 8-Bit CMOS Shift Register 331
9-6Using Shift Registers: Digital Roulette 333
9-7Troubleshooting a Simple Shift Register 338
Summary 340
Correlated Experiments 340
Chapter Review Questions 340
page viii
Critical Thinking Questions 342
Answers to Self-Tests 343
Chapter 10 Arithmetic Circuits 345
10-1Binary Addition 345
10-2Half Adders 347
10-3Full Adders 348
10-43-Bit Adders 350
10-5Binary Subtraction 351
10-6Parallel Subtractors 353
10-7IC Adders 355
10-8Binary Multiplication 358
10-9Binary Multipliers 360
10-102s Complement Notation, Addition, and Subtraction 363
10-112s Complement Adders/Subtractors 368
10-12Troubleshooting a Full Adder 370
Summary 372
Correlated Experiments 372
Chapter Review Questions 372
Critical Thinking Questions 373
Answers to Self-Tests 374
Chapter 11 Memories 377
11-1Overview of Memory 378
11-2Random-Access Memory (RAM) 381
11-3Static RAM ICs 383
11-4Using a SRAM 386
11-5Read-Only Memory (ROM) 388
11-6Using a ROM 391
11-7Programmable Read-Only Memory [PROM] 393
11-8Nonvolatile Read/Write Memory 397
11-9Memory Packaging 400
11-10Computer Bulk Storage Devices 403
11-11Digital Potentiometer: Using NV Memory 410
Summary 414
Correlated Experiments 415
Chapter Review Questions 415
Critical Thinking Questions 417
Answers to Self-Tests 417
Chapter 12 Simple Digital Systems 419
12-1Elements of a System 419
12-2A Digital System on an IC 422
12-3Digital Games 423
12-4The Digital Clock 425
12-5The LSI Digital Clock 429
12-6The Frequency Counter 434
12-7An Experimental Frequency Counter 439
12-8LCD Timer with Alarm 441
12-9Simple Distance Sensing 447
12-10JTAG/Boundary Scan 453
Summary 456
Correlated Experiments 456
Chapter Review Questions 456
Critical Thinking Questions 458
Answers to Self-Tests 459
Chapter 13 Computer Systems 461
13-1The Computer 461
13-2The Microcomputer 463
13-3Microcomputer Operation 466
13-4Microcomputer Address Decoding 470
13-5Data Transmission 473
13-6Detecting Errors in Data Transmissions 477
13-7Data Transmission in a Computer System 480
13-8Programmable Logic Controllers 485
13-9Microcontrollers 489
The BASIC Stamp Microcontroller Modules 491
13-11Digital Signal Processing 498
13-12DSP in a Digital Camera 502
13-13Microcontroller: Photo Input and Servo Motor Output 504
Summary 509
Correlated Experiments 509
Chapter Review Questions 510
Critical Thinking Questions 512
Answers to Self-Tests 513
Chapter 14 Connecting with Analog Devices 515
14-1D/A Conversion 516
14-2Operational Amplifiers 517
14-3A Basic D/A Converter 518
14-4Ladder-Type D/A Converters 520
14-5An A/D Converter 522
14-6Voltage Comparators 524
14-7An Elementary Digital Voltmeter 526
14-8Other A/D Converters 528
14-9A/D Converter Specifications 532
14-10An A/D Converter IC 533
14-11Digital Light Meter 536
14-12Digitizing Temperature 539
Summary 541
Correlated Experiments 541
Chapter Review Questions 541
Critical Thinking Questions 543
Answers to Self-Tests 544
Appendix A Solder and the Soldering Process 546
Appendix B 2s Complement Conversions 551
Glossary of Terms and Symbols 552
Index 566

->**********************************19_Maini_en.txt
Number Systems and Codes 1
Learning Objectives 1
1.1 Analogue Versus Digital 1
1.2 Introduction to Number Systems 2
1.3 Decimal Number System 2
1.4 Binary Number System 3
Advantages 4
1.5 Octal Number System 4
1.6 Hexadecimal Number System 4
1.7 Number Systems – Some Common Terms 5
Binary Number System 5
Decimal Number System 5
Octal Number System 5
Hexadecimal Number System 5
1.8 Number Representation in Binary 5
Sign-Bit Magnitude 5
1’s Complement 6
2’s Complement 6
1.9 Finding the Decimal Equivalent 6
Binary-to-Decimal Conversion 6
Octal-to-Decimal Conversion 6
Hexadecimal-to-Decimal Conversion 7
1.10 Decimal-to-Binary Conversion 7
1.11 Decimal-to-Octal Conversion 8
1.12 Decimal-to-Hexadecimal Conversion 9
1.13 Binary–Octal and Octal–Binary Conversion 9
1.14 Hex–Binary and Binary–Hex Conversion 10
1.15 Hex–Octal and Octal–Hex Conversion 10
1.16 The Four Axioms 11
1.17 Floating-Point Numbers 13
Range of Numbers and Precision 13
Floating-Point Number Formats 14
1.18 Binary Coded Decimal 17
BCD-to-Binary Conversion 18
Binary-to-BCD Conversion 18
Higher Density BCD Encoding 18
Packed and Unpacked BCD Numbers 19
1.19 Excess-3 Code 19
1.20 Gray Code 21
Binary–Gray Code Conversion 21
Gray Code–Binary Conversion 22
n-ary Gray Code 23
Applications 23
1.21 Alphanumeric Codes 25
ASCII Code 26
EBCDIC Code 29
Unicode 36
1.22 Seven-Segment Display Code 36
1.23 Error Detection and Correction Codes 36
Parity Code 38
Repetition Code 38
Cyclic Redundancy Check Code 38
Hamming Code 39
Key Terms 41
Review Questions 42
Problems 43
Objective Type Exercises 43
Answers 45
2 Digital Arithmetic 47
Learning Objectives 47
2.1 Basic Rules of Binary Addition and Subtraction 47
2.2 Addition of Larger Bit Binary Numbers 49
Addition Using the 2’s Complement Method 49
2.3 Subtraction of Larger Bit Binary Numbers 52
Subtraction Using 2’s Complement Arithmetic 53
2.4 BCD Addition and Subtraction in Excess-3 Code 56
Addition 56
Subtraction 56
2.5 Binary Multiplication 58
Repeated Left-Shift and Add Algorithm 58
Repeated Add and Right-Shift Algorithm 59
2.6 Binary Division 60
Repeated Right-Shift and Subtract Algorithm 60
Repeated Subtract and Left-Shift Algorithm 63
2.7 Floating-Point Arithmetic 65
Addition and Subtraction 65
Multiplication and Division 66
Key Terms 67
Review Questions 67
Problems 67
Objective Type Exercises 68
Answers 69
3 Logic Gates and Related Devices 71
Learning Objectives 71
3.1 Positive and Negative Logic 71
3.2 Truth Table 72
3.3 Logic Gates 73
OR Gate 73
AND Gate 75
NOT Gate 76
Exclusive-OR Gate 77
NAND Gate 80
NOR Gate 80
Exclusive-NOR Gate 80
INHIBIT Gate 83
3.4 Universal Gates 85
3.5 Gates with Open Collector/Drain Outputs 85
3.6 Tristate Logic Gates 87
3.7 AND-OR-INVERT Gates 87
3.8 Schmitt Gates 89
3.9 Special Output Gates 89
3.10 Fan-Out of Logic Gates 93
3.11 Buffers and Transceivers 95
3.12 IEEE/ANSI Standard Symbols 97
IEEE/ANSI Standards – Salient Features 97
3.13 Application-Relevant Information 99
Key Terms 101
Review Questions 101
Problems 102
Objective Type Exercises 102
Answers 104
4 Logic Families 107
Learning Objectives 107
4.1 Logic Families – Signifi cance and Types 107
Signifi cance 107
Types of Logic Families 108
4.2 Characteristic Parameters 109
4.3 Transistor Transistor Logic (TTL) 116
Standard TTL 116
Open Collector Gate 118
Low-Power TTL 119
High-Power TTL (74H/54H) 120
Schottky TTL (74S/54S) 121
Low-Power Schottky TTL (74LS/54LS) 122
Advanced Low-Power Schottky TTL (74ALS/54ALS) 123
Advanced Schottky TTL (74AS/54AS) 125
Fairchild Advanced Schottky TTL (74F/54F) 126
Floating and Unused Inputs 127
Current Transients and Power Supply Decoupling 127
4.4 Emitter Coupled Logic (ECL) 132
Different Sub-Families 132
Logic Gate Implementation in ECL 133
Salient Features of ECL 135
4.5 CMOS Logic Family 135
Circuit Implementation of Logic Functions 136
4.6 BiCMOS Logic 143
BiCMOS Inverter 144
BiCMOS NAND 144
4.7 NMOS and PMOS Logic 145
PMOS Logic 145
NMOS Logic 146
4.8 Integrated Injection Logic (I2L) Family 146
4.9 Comparison of Different Logic Families 148
4.10 Guidelines to Using TTL Devices 148
4.11 Guidelines to Handling and Using CMOS Devices 150
4.12 Interfacing with Different Logic Families 151
CMOS-to-TTL Interface 151
TTL-to-CMOS Interface 152
TTL-to-ECL and ECL-to-TTL Interface 154
CMOS-to-ECL and ECL-to-CMOS Interface 154
4.13 Classifi cation of Digital ICs 155
4.14 Application-Relevant Information 155
Key Terms 156
Review Questions 156
Problems 157
Objective Type Questions 158
Answers 160
5 Boolean Algebra and Simplifi cation Techniques 161
Learning Objectives 161
5.1 Introduction to Boolean Algebra 161
Variables, Literals, and Terms in Boolean Expressions 162
Equivalent and Complement of Boolean Expressions 162
Dual of a Boolean Expression 162
Postulates of Boolean Algebra 163
5.3 Theorems of Boolean Algebra 164
Theorem 1 (Operations with ‘0’ and ‘1’) 164
Theorem 2 (Operations with ‘0’ and ‘1’) 164
Theorem 3 (Idempotent or Identity Laws) 164
Theorem 4 (Complementation Law) 165
Theorem 5 (Commutative Laws) 165
Theorem 6 (Associative Laws) 165
Theorem 7 (Distributive Laws) 166
Theorem 8 167
Theorem 9 168
Theorem 10 (Absorption Law or Redundancy Law) 168
Theorem 11 168
Theorem 12 (Consensus Theorem) 169
Theorem 13 (DeMorgan’s Theorem) 170
Theorem 14 (Transposition Theorem) 171
Theorem 15 172
Theorem 16 172
Theorem 17 (Involution Law) 173
5.4 Simplifi cation Techniques 174
Sum-of-Products Boolean Expressions 175
Product-of-Sums Expressions 176
Expanded Forms of Boolean Expressions 176
Canonical Form of Boolean Expressions 177
Σ and Π Nomenclature 177
5.5 Quine–McCluskey Tabular Method 179
Tabular Method for Multi-Output Functions 183
5.6 Karnaugh Map Method 187
Construction of Karnaugh Map 187
Karnaugh Maps for Boolean Expressions with Larger Number of Variables 192
Karnaugh Maps for Multi-Output Functions 195
Key Terms 198
Review Questions 199
Problems 199
Objective Type Exercises 200
Answers 201
6 Arithmetic Circuits 203
Learning Objectives 203
6.1 Combinational Circuits 203
6.2 Implementing Combinational Logic 205
6.3 Arithmetic Circuits – Basic Building Blocks 206
Half-Adder 206
Full Adder 207
Half-Subtractor 209
Full Subtractor 211
Controlled Inverter 213
6.4 Adder–Subtractor 214
6.5 BCD Adder 215
6.6 Carry Propagation–Look-Ahead Carry Generator 222
6.7 Arithmetic Logic Unit (ALU) 227
6.8 Multipliers 227
6.9 Magnitude Comparator 229
Cascading Magnitude Comparators 229
6.10 Application-Relevant Information 233
Key Terms 234
Review Questions 234
Problems 234
Objective Type Exercises 235
Answers 237
7 Combinational Logic Circuits 239
Learning Objectives 239
7.1 Multiplexer 239
Inside the Multiplexer 240
Implementing Boolean Functions with Multiplexers 243
Multiplexers for Parallel-to-Serial Data Conversion 246
Cascading Multiplexer Circuits 248
7.2 Encoders 250
Priority Encoder 250
7.3 Demultiplexers and Decoders 254
Implementing Boolean Functions with Decoders 254
Cascading Decoder Circuits 256
7.4 Parity Generation and Checking 260
7.5 Application-Relevant Information 262
Key Terms 263
Review Questions 263
Problems 264
Objective Type Exercises 264
Answers 266
8 Flip-Flops and Related Devices 269
Learning Objectives 269
8.1 Multivibrator 269
Bistable Multivibrator 269
Schmitt Trigger 270
Monostable Multivibrator 272
Astable Multivibrator 273
8.2 Integrated Circuit (IC) Multivibrators 274
Digital IC-Based Monostable Multivibrator 274
IC Timer-Based Multivibrators 276
8.3 R-S Flip-Flop 284
R-S Flip-Flop with Active-LOW Inputs 284
R-S Flip-Flop with Active-HIGH Inputs 286
Clocked R-S Flip-Flop 287
8.4 Level-Triggered and Edge-Triggered Flip-Flops 290
8.5 J-K Flip-Flop 290
J-K Flip-Flop with PRESET and CLEAR Inputs 294
Master–Slave Flip-Flops 294
8.6 Toggle Flip-Flop (T Flip-Flop) 298
J-K Flip-Flop as Toggle Flip-Flop 300
8.7 D Flip-Flop 302
J-K Flip-Flop as D Flip-Flop 302
D-Type Latch 302
8.8 Synchronous and Asynchronous Inputs 304
8.9 Flip-Flop Timing Parameters 305
Set-Up and Hold Times 305
Propagation Delay 306
Clock Pulse HIGH and LOW Times 306
Asynchronous Input Active Pulse Width 307
Clock Transition Times 307
Maximum Clock Frequency 307
8.10 Flip-Flop Applications 307
Switch Debouncing 308
Flip-Flop Synchronization 308
Detecting Sequence of Edges 309
8.11 Application-Relevant Data 311
Key Terms 313
Review Questions 313
Problems 313
Objective Type Exercises 314
Answers 316
9 Counters and Registers 317
Learning Objectives 317
9.1 Ripple (Asynchronous) Counter 317
Propagation Delay in Ripple Counters 318
9.2 Synchronous Counter 319
9.3 Modulus of a Counter 319
9.4 Binary Ripple Counter – Operational Basics 319
Binary Ripple Counters with a Modulus of Less than 2N 322
Ripple Counters in IC Form 324
9.5 Synchronous (or Parallel) Counters 328
9.6 Up/Down Counters 330
9.7 Decade and BCD Counters 330
9.8 Presettable Counters 331
Variable Modulus with Presettable Counters 332
9.9 Decoding a Counter 334
9.10 Cascading Counters 337
Cascading Binary Counters 337
Cascading BCD Counters 337
9.11 Designing Counters with Arbitrary Sequences 341
Excitation Table of a Flip-Flop 342
State Transition Diagram 342
Design Procedure 342
9.12 Shift Register 350
Serial-In Serial-Out (SISO) Shift Register 351
Serial-In Parallel-Out (SIPO) Shift Register 353
Parallel-In Serial-Out (PISO) Shift Register 353
Parallel-In Parallel-Out (PIPO) Shift Register 354
Bidirectional Shift Register 355
Universal Shift Register 356
9.13 Shift Register Counters 359
Ring Counter 359
Shift Counter 360
9.14 IEEE/ANSI Symbology for Counters and Registers 364
Counters 365
Registers 366
9.15 Application-Relevant Information 366
Key Terms 368
Review Questions 368
Problems 369
Objective Type Questions 370
Answers 372
10 Data Conversion Circuits: D/A and A/D Converters 373
Learning Objectives 373
10.1 Digital-to-Analogue Converters 373
Simple Resistive Divider Network for D/A Conversion 374
Binary Ladder Network for D/A Conversion 375
10.2 D/A Convertor Specifi cations 376
Resolution 376
Accuracy 377
Conversion Speed or Settling Time 378
Dynamic Range 378
Nonlinearity and Differential Nonlinearity 378
Monotonocity 378
10.3 Types of D/A Converters 379
Multiplying-Type D/A Converters 379
Bipolar-Output D/A Converters 379
Companding D/A Converters 379
10.4 Modes of Operation 380
Current Steering Mode of Operation 380
Voltage Switching Mode of Operation 380
10.5 BCD-Input D/A Converter 382
10.6 Integrated Circuit D/A Converters 385
DAC-08 385
DAC-0808 385
DAC-80 385
AD 7524 387
DAC-1408/DAC-1508 388
10.7 D/A Converter Applications 388
D/A Converter as Multiplier 389
D/A Converter as a Divider 389
Programmable Integrator 389
Low-Frequency Function Generator 390
Digitally Controlled Filters 391
10.8 A/D Converters 393
10.9 A/D Converter Specifi cations 394
Resolution 394
Accuracy 394
Gain and Offset Errors 394
Gain and Offset Drifts 394
Sampling Frequency and Aliasing Phenomenon 394
Quantization Error 395
Nonlinearity 395
Differential Nonlinearity 395
Conversion Time 395
Aperture and Acquisition Times 396
Code Width 397
10.10 A/D Converter Terminology 397
Unipolar Mode Operation 397
Bipolar Mode Operation 397
Coding 397
Low Byte and High Byte 397
Right Justifi ed Data, Left Justifi ed Data 397
Command Register, Status Register 397
Control Lines 397
10.11 Types of A/D Converters 398
Simultaneous or Flash A/D Converters 398
Half-Flash A/D Converter 399
Counter-Type A/D Converter 401
Tracking-Type A/D Converter 402
Successive Approximation Type A/D Converter 403
Single, Dual, and Multi-Slope A/D Converters 404
Sigma-Delta A/D Converter 406
10.12 Integrated Circuit A/D Converters 411
ADC-0800 411
ADC-0808 412
ADC-80/AD ADC-80 412
ADC-84/ADC-85/AD ADC-84/AD ADC-85/AD-5240 412
AD 7820 414
ICL 7106/ICL 7107 414
10.13 A/D Converter Applications 417
Data Acquisition 418
Key Terms 418
Review Questions 418
Problems 419
Objective Type Questions 420
Answers 421
11 Programmable Logic Devices 423
Learning Objectives 423
11.1 Fixed Logic Versus Programmable Logic 423
Advantages and Disadvantages 424
11.2 Programmable Logic Devices: An Overview 426
Programmable ROMs 426
Programmable Logic Array (PLA) 426
Programmable Array Logic (PAL) 426
Generic Array Logic (GAL) 428
Complex Programmable Logic Device 429
Field Programmable Gate Array (FPGA) 430
11.3 Programmable ROMs 430
11.4 Programmable Logic Array (PLA) 435
11.5 Programmable Array Logic (PAL) 442
PAL Architecture 442
PAL Numbering System 443
11.6 Generic Array Logic (GAL) 448
11.7 Complex Programmable Logic Devices 449
Internal Architecture 449
Applications 451
11.8 Field-Programmable Gate Arrays 452
Internal Architecture 452
Applications 453
11.9 Programmable Interconnect Technologies 454
Fuse 454
Floating-Gate Transistor Switch 455
Static RAM-Controlled Programmable Switches 455
Antifuse 457
11.10 Design and Development of Programmable Logic Hardware 458
11.11 Programming Languages 459
ABEL-Hardware Description Language 459
VHDL-VHSIC Hardware Description Language 459
Verilog 460
Java HDL 460
Key Terms 460
Review Questions 460
Problems 461
Objective Type Exercises 462
Answers 464
12 Microprocessors 465
Learning Objectives 465
12.1 Introduction to Microprocessors 465
12.2 Evolution of Microprocessors 467
12.3 Inside a Microprocessor 468
Arithmetic Logic Unit (ALU) 468
Register File 469
Control Unit 470
12.4 Basic Microprocessor Instructions 472
Data Transfer Instructions 472
Arithmetic Instructions 472
Logic Instructions 472
Control Transfer or Branch or Program Control Instructions 473
Machine Control Instructions 474
12.5 Addressing Modes 474
Absolute or Memory Direct Addressing Mode 474
Immediate Addressing Mode 474
Register Direct Addressing Mode 475
Register Indirect Addressing Mode 475
Indexed Addressing Mode 475
Implicit Addressing Mode and Relative Addressing Mode 476
12.6 Microprocessor Selection 476
Selection Criteria 476
Microprocessor Selection Table for Common Applications 477
12.7 Programming Microprocessors 479
12.8 RISC Versus CISC Processors 480
12.9 Eight-Bit Microprocessors 480
The 8085 Microprocessor 480
The Motorola 6800 Microprocessor 483
The Zilog Z80 Microprocessor 484
12.10 16-Bit Microprocessors 485
The 8086 Microprocessor 485
The 80186 Microprocessor 487
The 80286 Microprocessor 487
The MC68000 Microprocessor 487
12.11 32-Bit Microprocessors 489
The 80386 Microprocessor 489
The MC68020 Microprocessor 491
The MC68030 Microprocessor 492
The 80486 Microprocessor 493
PowerPC RISC Microprocessors 495
12.12 Pentium Series of Microprocessors 495
Salient Features 496
Pentium Pro Microprocessor 496
Pentium II Series 497
Pentium III and Pentium IV Microprocessors 497
Pentium M, D, and Extreme Edition Processors 497
Celeron and Xeon Processors 497
12.13 Microprocessors for Embedded Applications 498
12.14 Peripheral Devices 498
Programmable Timer/Counter 498
Programmable Peripheral Interface (PPI) 498
Programmable Interrupt Controller (PIC) 499
DMA Controller 499
Programmable Communication Interface (PCI) 499
Math Coprocessor 499
Programmable Keyboard/Display Interface 500
Programmable CRT Controller 500
Floppy Disk Controller 500
Clock Generator 500
Octal Bus Transceiver 500
Key Terms 501
Review Questions 501
Objective Type Exercises 502
Answers 504
13 Microcontrollers 505
Learning Objectives 505
13.1 Introduction to Microcontroller 505
Applications 507
13.2 Inside the Microcontroller 507
Central Processing Unit (CPU) 507
Random Access Memory (RAM) 508
Read Only Memory (ROM) 508
Special-Function Registers 508
Peripheral Components 509
13.3 Microcontroller Architecture 514
Architecture to Access Memory 514
Mapping Special-Function Registers into Memory Space 515
Processor Architecture 515
13.4 Power-Saving Modes 518
13.5 Interfacing Peripheral Devices with a Microcontroller 518
Interfacing LEDs 518
Interfacing Electromechanical Relays 519
Interfacing Keyboards 519
Interfacing Seven-Segment Displays 521
Interfacing LCD Display 524
Interfacing A/D Converter 525
Interfacing D/A Converter 527
Key Terms 527
Review Questions 527
Problems 527
Objective Type Exercises 528
Answers 529
14 Memory Devices 531
Learning Objectives 531
14.1 Anatomy of a Computer 531
Central Processing Unit (CPU) 531
Memory 532
Input/Output Ports 533
14.2 A Computer System 533
14.3 Computer Memory 534
Primary Memory 534
14.4 Random Access Memory (RAM) 535
Static RAM (SRAM) 535
Dynamic RAM (DRAM) 540
Applications of RAM 543
14.5 Read Only Memory (ROM) 545
ROM Architecture 546
Types of ROM 547
Applications of ROM 551
14.6 Expanding Memory Capacity 555
Word Size Expansion 555
Memory Locations Expansion 556
14.7 Secondary Storage or Auxiliary Storage 560
Magnetic Storage Devices 560
Magneto-Optical Storage Devices 562
Optical Storage Devices 562
USB Flash Drive 564
Key Terms 564
Review Questions 564
Problems 565
Objective Type Exercises 565
Answers 567
Index 569
->**********************************20_Varela_en.txt
PREFACE 1
Chapter 1
INTRODUCTION 3
1NUMBERING SYSTEMS AND BASE CHANGES 3
2CODING 6
3BINARY CODED DECIMAL NUMBER (BCD) 7
4GRAY CODES 7
5ADDITION AND SUBTRACTION IN BASE TEN AND IN BASE TWO 9
6EXERCISES FROM CHAPTER 12
Chapter 2
BASIC LOGICAL GATES AND BOOLEAN ALGEBRA 15
1BASIC GATES 15
2BOOLEAN ALGEBRA 16
3RULES OF BOOLEAN ALGEBRA 17
4THE DUAL OF A BOOLEAN EQUATION 21
5MAPS OF KARNAUGH 22
6EQUALITY BETWEEN SUM OF PRODUCTS AND PRODUCT OF SUMS 28
7KARNAUGH MAP OF FIVE VARIABLES 29
8MAPS OF KARNAUGH WITH INDIFFERENCE 40
9SOLVED EXAMPLES 41
10EXERCISES FROM CHAPTER 47
Chapter 3
COMBINATIONAL LOGIC CIRCUITS 51
1SEVEN SEGMENT DISPLAY 51
2COMPARATOR OF TWO NUMBERS 54
3SEMIAMER AND FULL ADDER 54
4DECODERS 59
5ENCODERS 60
6PRIORITY 61 ENCODER
7MULTIPLEXERS 62
8DEMULTIPLEXERS 64
9EXERCISES FROM CHAPTER 65
Chapter 4
SEQUENTIAL LOGIC CIRCUITS 67
1PRELIMINARIES 67
2LATCHES AND FLIP FLOPS 70
3BASIC APPLICATIONS OF LATCHES AND FLIP FLOPS 79
4EXCITATION TABLES 82
5EXERCISES FROM CHAPTER 91
Appendix 1
COMBINATIONAL ANALYSIS 93
Appendix 2
TRANSISTORS 101
REFERENCE 104

->**********************************21_Ndjountche_en.txt
Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ix
Chapter 1. Number Systems . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2. Decimal numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.3. Binary numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.4. Octal numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.5. Hexadecimal numeration . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.6. Representation in a radix B . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.7. Binary-coded decimal numbers . . . . . . . . . . . . . . . . . . . . . . 7
1.8. Representations of signed integers . . . . . . . . . . . . . . . . . . . . . 8
1.8.1. Sign-magnitude representation . . . . . . . . . . . . . . . . . . . . . 9
1.8.2. Two’s complement representation . . . . . . . . . . . . . . . . . . . 10
1.8.3. Excess-E representation . . . . . . . . . . . . . . . . . . . . . . . . . 12
1.9. Representation of the fractional part of a number . . . . . . . . . . . . 13
1.10. Arithmetic operations on binary numbers . . . . . . . . . . . . . . . . 16
1.10.1. Addition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
1.10.2. Subtraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
1.10.3. Multiplication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
1.10.4. Division . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
1.11. Representation of real numbers . . . . . . . . . . . . . . . . . . . . . . 20
1.11.1. Fixed-point representation . . . . . . . . . . . . . . . . . . . . . . . 20
1.11.2. Floating-point representation . . . . . . . . . . . . . . . . . . . . . 22
1.12. Data representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
1.12.1. Gray code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
1.12.2. p-out-of-n code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
1.12.3. ASCII code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
1.12.4. Other codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
1.13. Codes to protect against errors . . . . . . . . . . . . . . . . . . . . . . 31
1.13.1. Parity bit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
1.13.2. Error correcting codes . . . . . . . . . . . . . . . . . . . . . . . . . 33
1.14. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
1.15. Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
Chapter 2. Logic Gates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
2.1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
2.2. Logic gates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
2.2.1. NOT gate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
2.2.2. AND gate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
2.2.3. OR gate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
2.2.4. XOR gate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
2.2.5. Complementary logic gates . . . . . . . . . . . . . . . . . . . . . . . 53
2.3. Three-state buffer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
2.4. Logic function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
2.5. The correspondence between a truth table and a logic function . . . . . 55
2.6. Boolean algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
2.6.1. Boolean algebra theorems . . . . . . . . . . . . . . . . . . . . . . . 59
2.6.2. Karnaugh maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
2.6.3. Simplification of logic functions with multiple outputs . . . . . . . 73
2.6.4. Factorization of logic functions . . . . . . . . . . . . . . . . . . . . 74
2.7. Multi-level logic circuit implementation . . . . . . . . . . . . . . . . . 76
2.7.1. Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
2.7.2. NAND gate logic circuit . . . . . . . . . . . . . . . . . . . . . . . . 78
2.7.3. NOR gate based logic circuit . . . . . . . . . . . . . . . . . . . . . . 80
2.7.4. Representation based on XOR and AND operators . . . . . . . . . 82
2.8. Practical considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
2.8.1. Timing diagram for a logic circuit . . . . . . . . . . . . . . . . . . . 90
2.8.2. Static hazard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
2.8.3. Dynamic hazard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
2.9. Demonstration of some Boolean algebra identities . . . . . . . . . . . . 93
2.10. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
2.11. Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
Chapter 3. Function Blocks of Combinational Logic . . . . . . . . . . 115
3.1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
3.2. Multiplexer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
3.3. Demultiplexer and decoder . . . . . . . . . . . . . . . . . . . . . . . . . 121
3.4. Implementation of logic functions using multiplexers or decoders . . . 127
3.4.1. Multiplexer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
3.4.2. Decoder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
3.5. Encoders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
3.5.1. 4:2 encoder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
3.5.2. 8:3 encoder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
3.5.3. Priority encoder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
3.6. Transcoders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
3.6.1. Binary code and Gray code . . . . . . . . . . . . . . . . . . . . . . . 143
3.6.2. BCD and excess-3 code . . . . . . . . . . . . . . . . . . . . . . . . . 149
3.7. Parity check generator . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
3.8. Barrel shifter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
3.9. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
3.10. Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
Chapter 4. Systematic Methods for the Simplification of
Logic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
4.1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
4.2. Definitions and reminders . . . . . . . . . . . . . . . . . . . . . . . . . . 203
4.2.1. Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
4.2.2. Minimization principle of a logic function . . . . . . . . . . . . . . 204
4.3. Karnaugh maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
4.3.1. Function of five variables . . . . . . . . . . . . . . . . . . . . . . . . 205
4.3.2. Function of six variables . . . . . . . . . . . . . . . . . . . . . . . . 207
4.3.3. Karnaugh map with entered variable . . . . . . . . . . . . . . . . . 208
4.3.4. Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
4.3.5. Representation based on the XOR and AND operators . . . . . . . 220
4.4. Systematic methods for simplification . . . . . . . . . . . . . . . . . . . 220
4.4.1. Determination of prime implicants . . . . . . . . . . . . . . . . . . 221
4.4.2. Finding the constitutive terms of a minimal expression . . . . . . . 224
4.4.3. Quine–McCluskey technique: simplification of incompletely
defined functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
4.4.4. Simplification of functions with multiple outputs . . . . . . . . . . 235
4.5. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
4.6. Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259
->**********************************22_Kani_en.txt
Preface vii
Chapter 1: Introduction to Digital Systems 1.1-1.6
1.1 Analog and Digital Electronics 1.1
1.2 Analog and Digital Signal 1.2
1.3 Binary Representation in Digital Systems 1.2
1.4 Digital Integrated Circuits (ICs) 1.3
1.5 Digital Systems 1.4
1.6 Binary Storage Devices: Registers and Memory 1.4
1.7 Binary Logic and Arithmetic 1.6
1.8 Logic Families 1.6
1.9 Hardware Discription Languages (HDLs) 1.6
Chapter 2: Number Systems 2.1–2.54
2.1 Review of Number Systems Representation and Conversions 2.1
2.1.1 Number Representation 2.2
2.1.2 Decimal Number System 2.2
2.1.3 Binary Number System 2.3
2.1.4 Octal Number System 2.7
2.1.5 Hexadecimal Number System 2.10
2.1.6 Relation between Binary, Octal and Hexadecimal Number Systems 2.13
2.2 Binary Arithmetic 2.15
2.2.1 Binary Addition 2.16
2.2.2 Binary Subtraction 2.16
2.2.3 Binary Multiplication 2.17
2.2.4 Binary Division 2.20
2.3 Unsigned and Signed Binary Number Systems 2.23
2.3.1 Unsigned Binary 2.23
2.3.2 Sign-Magnitude Form 2.24
2.3.3 Complement of Number Systems (r’s and (r - 1)’s Complement) 2.25
2.3.4 One’s Complement 2.26
2.3.5 Two’s Complement 2.28
2.3.6 One’s and Two’s Complement Addition 2.30
2.3.7 One’s and Two’s Complement Subtraction 2.33
2.4 Nine’s and Ten’s Complement 2.34
2.4.1 Nine’s and Ten’s Complement Addition 2.36
2.4.2 Nine’s and Ten’s Complement Subtraction 2.39
2.5 Summary of Important Concepts 2.40
2.6 Short-Answer Questions 2.42
2.7 Exercises 2.49
Chapter 3: Binary Codes 3.1–3.64
3.1 Introduction 3.1
3.1.1 Classification of Binary Codes 3.1
3.2 BCD Codes 3.3
3.2.1 8421 BCD 3.5
3.2.2 BCD Addition 3.6
3.2.3 BCD Subtraction 3.8
3.2.4 2421 Code 3.13
3.2.5 5421 Code 3.14
3.2.6 8, 4, - 2, -1 Code 3.16
3.2.7 Excess-3 Code 3.17
3.2.8 Excess-3 Addition 3.19
3.2.9 Excess-3 Subtraction 3.21
3.3 Gray Code 3.25
3.4 Alphanumeric Code 3.30
3.4.1 ASCII Code 3.30
3.4.2 EBCDIC Code 3.33
3.5 Error Detection and Correction 3.36
3.5.1 Parity 3.36
3.5.2 Hamming Code 3.37
3.5.3 Checksum 3.50
3.6 Summary of Important Concepts 3.54
3.7 Short-Answer Questions 3.56
3.8 Exercises 3.59
Chapter 4: Boolean Algebra and Logic Gates 4.1–4.114
4.1 Boolean Algebra 4.1
4.1.1 Duality 4.2
4.1.2 Postulates of Boolean Algebra 4.2
4.1.3 Boolean Theorems 4.5
4.2 Binary Logic 4.8
4.3 Logic Gates 4.9
4.3.1 Universal Gates 4.13
4.3.2 Positive and Negative Logic Gates 4.17
4.4 Boolean Functions 4.20
4.4.1 Implementation of Boolean Functions by Logic Gates 4.23
4.4.2 Minterms 4.24
4.4.3 Maxterms 4.25
4.4.4 Standard Forms 4.26
4.4.5 Sum-of-Products and Product-of-Sums Simplification 4.27
4.4.6 Canonical Form 4.28
4.4.7 Complement of a Function 4.28
4.4.8 Implementation of Boolean Functions using Universal Gates 4.29
4.4.9 Implementation of Logic Design using Standard Logic Gate IC’s 4.38
4.4.10 Implementation of Logic Design using Standard Universal Gate IC’s 4.40
4.5 Simplification of Boolean Expressions or Functions 4.43
4.6 Karnaugh Map (or K-map) Minimization 4.44
4.6.1 Realization of Sum-of-Products Form using K-map 4.44
4.6.2 Two-Variable K-map 4.45
4.6.3 Three-Variable K-map 4.47
4.6.4 Four-Variable K-map 4.50
4.6.5 Five-Variable K-map 4.53
4.6.6 Realization of Product-of-Sums Form using K-map 4.63
4.6.7 Completely and Incompletely Specified Functions 4.64
(K-map with Don’t-Care Conditions)
4.7 Quine-McCluskey (QM) Method of Minimization 4.78
(Table Method of Minimization)
4.8 Summary of Important Concepts 4.87
4.9 Short-Answer Questions 4.89
4.10 Exercises 4.100
Chapter 5: Combinational Logic Circuits 5.1–5.190
5.1 Introduction 5.1
5.2 Combinational Circuits 5.1
5.2.1 K-map Representation and Minimization using K-maps 5.2
5.2.2 Problem Formulation and Design of Combinational Circuits 5.2
5.3 Code Converters 5.7
5.4 Decoders 5.16
5.4.1 Logic High 2-to-4 Decoder 5.17
5.4.2 Logic Low 2-to-4 Decoder 5.19
5.4.3 Logic High 2-to-4 Decoder with Logic High Enable 5.20
5.4.4 Logic High 2-to-4 Decoder with Logic Low Enable 5.22
5.4.5 Logic Low 2-to-4 Decoder with Logic High Enable 5.25
5.4.6 Logic Low 2-to-4 Decoder with Logic Low Enable 5.28
5.4.7 Logic High 3-to-8 Decoder 5.31
5.4.8 Logic Low 3-to-8 Decoder 5.33
5.4.9 Expanding the Decoder 5.36
5.4.10 Combinational Circuit Design using Decoder 5.40
5.4.11 Implementation of Combinational Logic Design using 5.46
Standard Decoder IC’s
5.5 Encoders 5.50
5.5.1 Logic High 4-to-2 Encoder 5.50
5.5.2 Logic High 8-to-3 Encoder 5.52
5.6 Priority Encoders 5.54
5.6.1 Logic High 4-to-2 Priority Encoder 5.55
5.6.2 Logic High 4-to-2 Priority Encoder Design using K-maps 5.57
5.6.3 Logic High 8-to-3 Priority Encoder 5.58
5.7 Multiplexer 5.62
5.7.1 Expanding the Multiplexer 5.67
5.7.2 Combinational Circuit Design using Multiplexer 5.74
5.7.3 Implementation of Combinational Logic Design using 5.86
Standard Multiplexer IC’s
5.8 Demultiplexer 5.95
5.8.1 Expanding the Demultiplexer 5.101
5.8.2 Demultiplexers and Decoders 5.102
5.9 Adders 5.103
5.9.1 Half Adder 5.103
5.9.2 Full Adder 5.104
5.9.3 Binary Parallel Adder 5.112
5.9.4 Carry Look Ahead Adder 5.115
5.9.5 BCD Adder 5.118
5.10 Subtractors 5.122
5.10.1 Half Subtractor 5.122
5.10.2 Full Subtractor 5.123
5.11 Parallel Adder/Subtractor 5.128
5.11.1 Binary Parallel Adder/Subtractor 5.128
5.11.2 BCD Subtractor 5.130
5.11.3 BCD Adder/Subtractor 5.131
5.12 Magnitude Comparator 5.131
5.12.1 4-bit Magnitude Comparator 5.131
5.12.2 3-bit Magnitude Comparator 5.137
5.12.3 2-bit Magnitude Comparator 5.138
5.13 Combinational Multiplier 5.139
5.13.1 Combinational 2-bit Binary Multiplier 5.139
5.13.2 Combinational 4-bit Binary Multiplier 5.140
5.14 Arithmetic and Logic Unit 5.142
5.14.1 Design of 4-bit ALU 5.142
5.14.2 ALU using Standard IC’s 5.147
5.14.3 8-bit and 16-bit ALU using 74381/382 5.147
5.14.4 8-bit and 16-bit ALU using 74181 5.150
5.15 Combinational Systems Case Study 5.153
5.15.1 Digital Trans-Receiver 5.153
5.15.2 Parallel Data Trans-Receiver 5.153
5.15.3 Serial Data Trans-Receiver 5.154
5.15.4 Parity Generator and Checker 5.155
5.15.5 BCD to 7-Segment Decoder 5.160
5.16 Summary of Important Concepts 5.166
5.17 Short-Answer Questions 5.167
5.18 Exercises 5.174
Chapter 6: Latches and Flip-Flops 6.1–6.80
6.1 Bistable Element and Latches 6.1
6.1.1 SR Latch 6.2
6.1.2 Analysis of SR Latch using NOR Gates 6.2
6.1.3 Analysis of SR Latch using NAND Gates 6.5
6.1.4 D Latch 6.10
6.1.5 Application of Latches-Swith Debouncing 6.11
6.2 Flip-Flops 6.14
6.2.1 Clock and Triggering of Flip-Flops 6.14
6.2.2 SR Flip-Flop 6.16
6.2.3 JK Flip-Flop 6.22
6.2.4 T Flip-Flop (Toggle Flip-Flop) 6.29
6.2.5 D Flip-Flop (Data Flip-Flop) 6.31
6.2.6 Flip-Flop with Preset and Reset Facility 6.33
6.3 Master-Slave Flip-Flop 6.34
6.4 Excitation Table and Characteristic Equation of Flip-Flops 6.36
6.4.1 Excitation Table of D Flip-Flop 6.36
6.4.2 Excitation Table of JK Flip-Flop 6.38
6.4.3 Excitation Table of T Flip-Flop 6.40
6.4.4 Excitation Table of SR Flip-Flop 6.41
6.5 Conversion of Flip-Flops 6.43
6.5.1 Conversion of SR to JK Flip-Flop 6.43
6.5.2 Conversion of SR to D Flip-Flop 6.44
6.5.3 Conversion of SR to T Flip-Flop 6.45
6.5.4 Conversion of JK Flip-Flop to SR, D and T Flip-Flops 6.46
6.5.5 Conversion of D to SR Flip-Flop 6.46
6.5.6 Conversion of D to JK Flip-Flop 6.48
6.5.7 Conversion of D to T Flip-Flop 6.49
6.5.8 Conversion of T to SR Flip-Flop 6.50
6.5.9 Conversion of T to JK Flip-Flop 6.51
6.5.10 Conversion of T to D Flip-Flop 6.53
6.6 Summary of Important Concepts 6.68
6.7 Short-Answer Questions 6.69
6.8 Exercises 6.70
Chapter 7: Synchronous Sequential Circuits 7.1–7.84
7.1 Introduction 7.1
7.2 Analysis and Design of Synchronous (or Clocked) Sequential Circuits 7.2
7.2.1 Design of Mealy and Moore Models 7.2
7.3 State and State Equations 7.3
7.3.1 State Table and State Diagram 7.4
7.3.2 State Reduction 7.5
7.3.3 State Assignment 7.6
7.3.4 Lock-out Condition Circuit Implementation 7.7
7.4 Implementation of Sequential Logic Design using Standard IC’s 7.68
7.5 Summary of Important Concepts 7.73
7.6 Short-Answer Questions 7.74
7.7 Exercises 7.75
Chapter 8: Sequential Logic-Counters and Registers 8.1–8.134
8.1 Design of Counters 8.1
8.2 Asynchronous or Ripple Counter 8.2
8.2.1 Up Counter 8.2
8.2.2 Down Counter 8.4
8.2.3 Up/Down Counter using T Flip-Flop 8.6
8.2.4 Down Counter with Positive Clock 8.7
8.2.5 BCD Counter 8.8
8.2.6 MOD Counter 8.11
8.3 Synchronous Counter 8.15
8.3.1 Synchronous Binary Up Counter 8.16
8.3.2 Synchronous Binary Down Counter 8.19
8.3.3 Synchronous Up/Down Counter 8.21
8.3.4 Synchronous BCD Counter 8.22
8.3.5 Ring Counter 8.26
8.3.6 Johnson Counter 8.27
8.3.7 Application of Counter 8.104
8.4 Implementation of Counters using Standard ICs 8.104
8.5 Register 8.111
8.6 Shift Register 8.113
8.6.1 Serial-in Serial-out Shift Register 8.113
8.6.2 Serial-in Parallel-out Shift Register 8.116
8.6.3 Parallel-in Serial-out Shift Register 8.116
8.6.4 Parallel-in Parallel-out Shift Register 8.117
8.6.5 Universal Shift Register 8.117
8.6.6 Application of Shift Register 8.121
8.7 Synchronous Systems Model Development 8.122
8.7.1 Designing of Rolling Display 8.123
8.7.2 Designing of Real Time Clock 8.123
8.8 Summary of Important Concepts 8.125
8.9 Short-Answer Questions 8.126
8.10 Exercises 8.128
Contents xvii
Chapter 9: Asynchronous Sequential Circuits 9.1–9.110
9.1 Introduction to Asynchronous Sequential Logic Circuits 9.1
9.1.1 Fundamental and Pulse Mode Sequential Circuits 9.2
9.1.2 Transition Table 9.2
9.1.3 Stable and Unstable States 9.5
9.1.4 Flow Table 9.6
9.1.5 Cycles and Races 9.6
9.1.6 Race-Free Assignment 9.25
9.1.7 Transition Diagram 9.26
9.2 State Reduction 9.32
9.2.1 Implication Table 9.33
9.2.2 Merger Diagram to find Equivalent State Groups 9.36
9.2.3 Merging of Rows of Flow Tables with Incompletely Specified States 9.42
9.2.4 Merger Diagram to find Maximum Compatible States 9.42
9.2.5 Maximum Compatible 9.43
9.2.6 Closed-Covering Condition 9.43
9.2.7 Assigning Outputs in Flow Table with Incompletely Specified States 9.43
9.3 Asynchronous Circuits with SR Latches 9.52
9.3.1 NOR based SR Latch 9.52
9.3.2 NAND based SR Latch 9.53
9.3.3 Design using SR Latches 9.54
9.4 Design of Pulse Mode Asynchronous Sequential Circuits 9.72
9.5 Summary of Important Concepts 9.90
9.6 Short-Answer Questions 9.92
9.7 Exercises 9.97
Chapter 10: Hazards 10.1–10.50
10.1 Hazards 10.1
10.2 Hazards in Combinational Circuits 10.1
10.2.1 Static-0 and Static-1 Hazards 10.1
10.2.2 Dynamic Hazard 10.6
10.3 Hazards in Sequential Circuits 10.7
10.4 Essential Hazards 10.7
10.5 Design of Hazard Free Circuits 10.12
10.5.1 Elimination of Hazards in Combinational Circuits 10.12
10.5.2 Elimination of Hazards in Sequential Circuits 10.18
10.6 Summary of Important Concepts 10.39
10.7 Short-Answer Questions 10.40
10.8 Exercises 10.41
Chapter 11: Logic Families 11.1–11.74
11.1 Logic Families 11.1
11.1.1 Evolution of Logic Family 11.1
11.2 Operation and Characteristics of Digitial Logic Families 11.2
11.2.1 Logic Levels 11.2
11.2.2 Propagation Delay 11.3
11.2.3 Power Requirement 11.4
11.2.4 Fan-out and Fan-in 11.5
11.2.5 Noise Margin 11.5
11.2.6 ON-OFF Characteristics of Bipolar Junction Transistors 11.7
11.2.7 ON-OFF Characteristics of CMOS Field Effect Transistors 11.8
11.3 RTL (Resistor-Transistor Logic) 11.10
11.3.1 RTL NOR Gate 11.10
11.3.2 RTL OR Gate 11.11
11.3.3 RTL NAND Gate 11.12
11.3.4 RTL AND Gate 11.14
11.3.5 RTL NOT Gate 11.15
11.4 DTL (Diode-Transistor Logic) 11.15
11.4.1 DTL NAND Gate 11.15
11.4.2 DTL NOR Gate 11.17
11.4.3 DTL NOT Gate 11.18
11.4.4 DTL AND Gate 11.19
11.4.5 DTL OR Gate 11.20
11.5 TTL (Transistor-Transistor Logic) 11.20
11.5.1 Types of Output in TTL Devices 11.20
11.5.2 TTL NAND Gate 11.22
11.5.3 TTL NOT Gate 11.24
11.5.4 TTL AND Gate 11.25
11.5.5 TTL NOR Gate 11.25
11.5.6 TTL OR Gate 11.27
11.6 ECL (Emitter Coupled Logic) 11.27
11.6.1 Emitter Coupled Current Switch 11.28
11.6.2 Emitter Coupled Basic Gate Circuit 11.29
11.6.3 ECL NOR Gate 11.33
11.6.4 ECL OR Gate 11.35
11.6.5 ECL NOT Gate 11.37
11.6.6 ECL NAND Gate 11.38
11.6.7 ECL AND Gate 11.41
11.7 CMOS (Complementary MOSFET) 11.43
11.7.1 CMOS NOT Gate 11.44
11.7.2 CMOS NOR Gate 11.44
11.7.3 CMOS OR Gate 11.46
11.7.4 CMOS NAND Gate 11.47
11.7.5 CMOS AND Gate 11.48
11.7.6 Buffered and Unbuffered CMOD Devices 11.49
11.7.7 Combinational Logic Implementation in CMOS 11.49
11.8 Comparison of Logic Families 11.60
11.8.1 Resistor-Transistor Logic (RTL) Family 11.61
11.8.2 Diode-Transistor Logic (DTL) Family 11.61
11.8.3 Transistor-Transistor Logic (TTL) Family 11.62
11.8.4 Emitter-Coupled Logic (ECL) Family 11.63
11.8.5 Complementary MOSFET Logic (CMOS) Family 11.63
11.9 Summary of Important Concepts 11.64
11.10 Short-Answer Questions 11.66
11.11 Exercises 11.68
Chapter 12: Memory and Programmable Logic Devices 12.1–12.78
12.1 Basic Concepts of Memory 12.1
12.1.1 Types of Semiconductor Memories 12.2
12.1.2 Functional Block Diagram of Semiconductor Memory 12.3
12.1.3 Memory or Binary Cell (BC) 12.5
12.1.4 Address Decoding in Memory 12.7
12.1.5 Address Multiplexing in Memory 12.8
12.2 ROM and PROM 12.11
12.2.1 Custom or Mask Programmed ROM 12.11
12.2.2 Programmable or Field Programmable ROM 12.12
12.2.3 EPROM 12.13
12.2.4 EEPROM/EAPROM 12.16
12.3 RAM 12.17
12.3.1 Static RAM 12.17
12.3.2 DRAM 12.21
12.3.3 Content-Addressable Memory (CAM) 12.23
12.4 Programmable Logic Devices 12.27
12.5 PROM as PLD 12.27
12.6 PLA (Programmable Logic Array) 12.31
12.6.1 Implementation of Combinational Circuit using PLA 12.33
12.7 PAL (Programmable Array Logic) 12.44
12.7.1 Implementation of Combinational Circuit using PAL 12.46
12.8 Sequential Programmable Logic Device (SPLD) 12.53
12.9 Complex Programmable Logic Device (CPLD) 12.54
12.10 Field Programmable Gate Array (FPGA) 12.55
12.10.1 Basic Architecture of FPGA 12.55
12.10.2 Xilinx FPGA Family of Devices 12.58
12.10.3 Spartan-6 Family of FPGA 12.58
12.10.4 Spartan-6 FPGA Architecture 12.60
12.11 Summary of Important Concepts 12.63
12.12 Short-Answer Questions 12.64
12.13 Exercises 12.69
Chapter 13: Data Converters 13.1–13.30
13.1 Introduction 13.1
13.1.1 Parameters of Data Converters 13.2
13.2 Digital to Analog Converter (DAC) 13.3
13.2.1 R-2R Ladder Type DAC 13.4
13.2.2 Weighted-Resistor Type DAC 13.5
13.2.3 Switched Current-Source Type DAC 13.6
13.2.4 Switched Capacitor Type DAC 13.7
13.2.5 DAC0800 13.9
13.3 Analog to Digital Converter (ADC) 13.10
13.3.1 Flash Type ADC 13.11
13.3.2 Counter Type ADC 13.13
13.3.3 Tracking Type ADC 13.14
13.3.4 Dual-Slope Type ADC 13.15
13.3.5 Successive-Approximation Type ADC 13.16
13.3.6 ADC0809 13.17
13.4 Summary of Important Concepts 13.22
13.5 Short-Answer Questions 13.23
13.6 Exercises 13.26
Chapter 14: VHDL 14.1–14.140
14.1 Introduction to VHDL 14.1
14.2 Elements of VHDL Language 14.2
14.2.1 Literals 14.2
14.2.2 Comments 14.3
14.2.3 Identifiers 14.3
14.2.4 Predefined Data Types 14.4
14.2.5 Data Types and Subtypes 14.6
14.2.6 Scalar Data Types 14.6
14.2.7 Composite Data Types 14.7
14.2.8 Access Data Types 14.8
14.2.9 Data Objects (or Objects) 14.8
14.2.10 Operators 14.9
14.3 Process and Process Statement 14.11
14.4 Sequential Statements 14.12
14.4.1 Variable Assignment Statement 14.12
14.4.2 Signal Assignment Statement 14.13
14.4.3 Wait Statement 14.13
14.4.4 IF Statement 14.13
14.4.5 Case Statement 14.15
14.4.6 Loop Statement 14.15
14.4.7 Exit Statement 14.17
14.4.8 Next Statement 14.17
14.4.9 Null Statement 14.18
14.4.10 Assertion Statement 14.18
14.5 Concurrent Statements 14.20
14.5.1 Concurrent Signal Assignment Statement 14.20
14.5.2 Conditional Signal Assignment Statement 14.20
14.5.3 Selected Signal Assignment Statement 14.20
14.5.4 Concurrent Assertion Statement 14.21
14.6 VHDL Design Entity (or Model) 14.21
14.6.1 Entity Declaration 14.22
14.6.2 Architeture Body 14.23
14.6.3 Component Declaration 14.24
14.6.4 Component Instantiation 14.24
14.6.5 VHDL Programs for Half Adder with Three Different Architecture 14.24
14.7 Subprograms 14.26
14.7.1 Procedure 14.26
14.7.2 Functions 14.27
14.8 Introduction to Packages 14.28
14.8.1 Package Body 14.29
14.9 Library 14.30
14.10 Test Bench 14.32
14.11 RTL Design 14.33
14.11.1 Combinational Logic 14.35
14.11.2 Sequential Logic 14.36
14.12 VHDL Programs without Test Bench 14.37
14.13 VHDL Programs with Test Bench 14.73
14.14 VHDL Programs in RTL Methodology 14.123
14.15 Summary of Important Concepts 14.132
14.16 Short-Answer Questions 14.133
14.17 Exercises 14.137
Chapter 15: VERILOG 15.1–15.98
15.1 Introduction to Verilog 15.1
15.2 Elements of Verilog Language 15.1
15.2.1 Identifiers 15.2
15.2.2 Keywords 15.2
15.2.3 Comments 15.3
15.2.4 Logic Values in Verilog 15.3
15.2.5 Number Representation in Verilog 15.3
15.3 Operators in Verilog Language 15.3
15.4 Data Types in Verilog 15.5
15.4.1 Net Data Types 15.6
15.4.2 Variable Data Types 15.7
15.5 Verilog Primitives 15.8
15.5.1 User Defined Primitives (UDP) 15.9
15.6 Verilog Statements and Loops 15.10
15.6.1 Continuous Assignment Statement 15.10
15.6.2 Procedural Assignment Statement 15.11
xxii Digital Logic Circuits
15.6.3 If and If-else Statement 15.12
15.6.4 Case Statement 15.14
15.6.5 While Loop 15.15
15.6.6 For Loop 15.15
15.6.7 Forever and Repeat Loop 15.16
15.7 Function in Verilog 15.16
15.8 Task in Verilog 15.17
15.9 Timescale and Timing Control 15.18
15.9.1 Delay Control (#) 15.19
15.9.2 Event Control 15.19
15.9.3 Wait Statement 15.19
15.10 Verilog Program Structure 15.19
15.10.1 Module 15.20
15.10.2 Declarations 15.20
15.10.3 Initial Block 15.21
15.10.4 Always Block 15.21
15.11 Types of Program Modeling in Verilog 15.22
15.11.1 Dataflow Model 15.22
15.11.2 Behavior Model 15.22
15.11.3 Structural Model 15.22
15.12 Test Bench 15.24
15.13 Verilog Programs Without Test Bench 15.24
15.14 Verilog Programs With Test Bench 15.48
15.15 Summary of Important Concepts 15.90
15.16 Short-Answer Questions 15.92
15.17 Exercises 15.94
Appendices A A.1–A.26
APPENDIX 1: List of Some Standard IC’s A.1
APPENDIX 2: Pin Configuration of Some Standard IC’s A.2
APPENDIX 3: Summary of Various Binary Codes A.12
APPENDIX 4: Unsigned and Signed Binary Number System A.14
APPENDIX 5: Boolean Theorems A.15
APPENDIX 6: Two Variable Boolean Function A.16
APPENDIX 7: Summary of Flip-Flop Tables A.17
APPENDIX 8: List of Xillinx FPGAs A.18
APPENDIX 9: Spartan-6 FPGA Feature and Logic Resources A.20
APPENDIX 10: Reserved Words in VHDL A.21
APPENDIX 11: Data Types and Operators in VHDL A.22
APPENDIX 12: Keywords in Verilog A.24
APPENDIX 13: Operators and Net Data Types in Verilog A.25
University Question Papers Q.1–Q.48
Index I.1–I.6
->**********************************23_Groote_en.txt
1 Basic components and combinatorial circuits 1
1.1 The three basic logic gates 1
1.2 Other logic gates 4
1.3 Physical realisation of gates 5
1.3.1 MOSFET transistors 5
1.3.2 CMOS gates 6
1.3.3 Switching delays 7
1.3.4 Moore’s law 8
1.4 Algebraic manipulation and duality 11
1.5 Two-layer circuits 14
1.6 Karnaugh maps 17
1.7 Functional completeness of the nand gate 20
1.8 Multiplexers 21
1.9 Summary 22
2 Numbers, basic circuits, and the ALU 23
2.1 Representation of unsigned numbers23
2.2 Two’s complement representation of integers 27
2.3 Adding unsigned numbers 30
2.4 Adding two’s complement numbers 33
2.5 Subtraction 35
2.6 Comparing unsigned and two’s complement numbers 36
2.7 Arithmetic circuits: addition and subtraction 38
2.7.1 Addition: the half- and full adder 38
2.7.2 Subtraction 39
2.7.3 The carry look-ahead adder 40
2.8 The arithmetic logic unit (ALU) 42
2.9 Multiplication 45
2.10 Alternative representations for numbers 46
2.10.1 Sign and magnitude 47
2.10.2 One’s complement 47
2.10.3 Floating-point numbers 48
2.10.4 Parity bits and Hamming codes48
2.10.5 Gray code 48
2.11 Representation of character sets 50
2.12 Summary 51
3 Sequential circuits 53
3.1 A one-time latch 53
3.2 The set-reset flip-flop/set-reset latch 54
3.3 The D-latch/D-flip-flop 55
3.4 Registers 59
3.5 Finite state machines 60
3.5.1 An example state machine with four states 61
3.5.2 Encoding the state machine 61
3.5.3 Realising the state machine using logic gates and flip-flops 63
3.6 Random access memory 67
3.7 Finite state machines to control registers 68
3.8 Hardware description languages 70
3.9 Summary 71
4 An elementary processor 73
4.1 The general structure of the processor 74
4.2 The instruction set 77
4.3 The instruction fetch and the register transfer language 81
4.4 The format of machine code instructions 83
4.5 Implementing instructions on the processor 85
4.6 Optimisation of the execution of instructions 88
4.7 More advanced instructions 91
4.8 Input and output 93
4.9 Interrupts 96
4.10 Summary 97
5 Assembly programming 99
5.1 Labels and comments, EQU and CONS 99
5.2 Arithmetic calculations 102
5.3 A timed loop 104
5.4 Basic data structures 105
5.4.1 Arrays 105
5.4.2 Stacks 106
5.4.3 Linked lists 109
5.5 Memory layout 110
5.5.1 Allocation dependence 111
5.5.2 Relocatable code and data 112
5.6 Subroutines 112
5.6.1 Saving the return address 113
5.6.2 Returning values 115
5.6.3 Passing arguments on the stack 116
5.6.4 Local variables 118
5.7 Interrupt routines 120
5.7.1 Interrupt handlers 120
5.7.2 Installing handlers 122
5.7.3 An example: displaying keyboard strokes 122
5.8 Multitasking and multithreading 125
5.8.1 Timer interrupts and context switching 125
5.8.2 Data structures for multitasking 126
5.9 Summary 129
6 Compiling higher-level languages 131
6.1 A simple higher-level programming language 132
6.2 Context free grammars and parsing 134
6.3 Type checking 136
6.4 Compilation scheme 137
6.5 Compiler optimisation 143
6.6 Compilation of other language constructs 144
6.6.1 Input/output 145
6.6.2 More complex data types 145
6.6.3 Parameter passing 145
6.6.4 Classes and objects 147
6.6.5 Flow control 147
6.6.6 Exception handling 147
6.7 Summary 148
7 Computer organisation 149
7.1 Starting a computer system 149
7.1.1 The Basic Input Output System and the Power On Self Test 150
7.1.2 The boot loader 151
7.1.3 Unified Extensible Firmware Interface 152
7.2 Operating systems 152
7.2.1 Processor modes 154
7.2.2 System calls 156
7.3 Memory organisation 158
7.3.1 Virtual memory 159
7.3.2 Replacement policies 161
7.3.3 Translation look aside buffers 162
7.3.4 Code, stack, data and other segments 162
7.4 Caches 163
7.4.1 Placement policies 164
7.5 Multi- and many-core processor machines 166
7.6 Summary 168
8 The Raspberry Pi and the ARM processor 169
8.1 Raspberry Pi overview 169
8.2 The ARM architecture 171
8.2.1 ARM architecture instruction sets 172
8.2.2 ARM architecture profiles 173
8.2.3 ARM security modes 174
8.3 Virtual memory (the memory management unit) 174
8.3.1 Memory attributes 175
8.3.2 Memory attributes and the VMMU 176
8.3.3 The system memory management unit 176
8.4 The ARM instruction set 178
8.4.1 Instruction groups 180
8.4.2 Setting flags and conditional execution 184
8.4.3 Arguments and addressing modes 186
8.5 The ARM calling convention 191
8.6 The use of system calls 192
8.7 Summary 193
A An extended instruction set for the simple processor 195
B The ARM 32-bit instruction set 197
C Syntax of the register transfer language 201
Answers to the exercises 203
D.1 Answers for Chapter 1 203
D.2 Answers for Chapter 2 210
D.3 Answers for Chapter 3 216
D.4 Answers for Chapter 4 224
D.5 Answers for Chapter 5 231
D.6 Answers for Chapter 6 240
D.7 Answers for Chapter 7 244
D.8 Answers for Chapter 8 245
References 247
Index 249

->**********************************24_El-Sheikh_en.txt
Preface
1- Introduction
1
1.1 History of Computational Fabrics
1
Evolution of Electronic Digital Devices
Basic Digital System Concepts
Digital System Design
Hierarchical System Design
1.2 Digital Systems
3
Levels of Integrated Circuits
Types of VLSI Chips
Digital Systems
Digital System Design Levels
Advantages of Digital Systems
Analog vs. Digital Systems
Building binary digital solutions to computational problems
Hardware Description Language (HDL)
Embedded Digital System
A Wireless Microsensor System
Temporal Representations of Electronic Signals:
Stored Program Digital Computer
Digital Computer Basic Operation
2- Numbers Systems and Codes 12
2.1 Introductory Background
2.1.1 Motivation
2.1.2 Computers and Numbers 13
2.1.3 Binary Number System Applications 16
2.2 Decimal (Base 10) Numbers 17
2.3 Binary (Base 2) Numbers 18
2.4 Octal (Base 8) Numbers 20
2.5 Hexadecimal (Base 16) Numbers 21
2.6 Numbers Conversions 23
2.6.1 Decimal Conversions 24
2.6.2 Binary Conversions 32
Binary into Decimal
Binary into Octal
Binary into Hexadecimal
2.6.3 Octal Conversions 35
Decimal and Octal Conversion
2.6.4 Hexadecimal Conversion 36
Decimal and Hexadecimal Conversion
2.6.5 Generalized Conversions 37
2.7 Numbers' Arithmetic 39
2.7.1 Binary Addition
2.7.2 Binary Subtraction
2.7.3 Signed Binary Numbers 40
Complementary Arithmetic
9’s and 10’s Complement
Signed Magnitude
1’s Complement
2’s Complement
Arithmetic Operations with Signed Numbers
Operations with Negative Numbers 46
Two’s Complement Motivation
2.7.4 Octal Arithmetic 48
Octal Addition
Octal Subtraction
2.7.5 Hexadecimal Arithmetic 9
Hexadecimal Addition
Hexadecimal Subtraction
2.8 Binary Multiplication and Division 53
2.9 Codes 55
2.9.1 Numerical (Binary) Codes 55
Classifications of Binary Codes
2.9.2 Binary-Coded Decimal (BCD) 56
BCD in Electronics
Packed BCD
BCD Conversion
BCD Addition
BCD Subtraction
Comparison with pure binary
Disadvantages
2.9.3 Gray Code 63
Binary to gray code conversion
Gray code to binary conversion
2.9.4 Excess-3 Code 65
Addition of two numbers in Excess-3 Code
2.9.5 Bi-quinary coded decimal Code; Decoding 66
2.9.6 Character (Alphanumeric) Codes 68
2.9.6.1 EBCDIC Code
2.9.6.2 ASCII Code
Parity Method
Cyclic Redundancy Check
Background
2.9.7 Error Detection and Correction 71
2.10 Binary Number System Applications 74
2.10.1 Binary Numbers in Electronics
2.10.2 Binary Bits of Zeros and Ones
2.10.3 Analogue Voltage Output
2.10.4 Digital Voltage Output
2.10.5 Digital Logic Levels
2.11 Exercises: Numbers' Systems and Codes 77
3- Logic Gates 79
3.1 Binary Logic 80
3.2 Logic Operations 81
3.2.1 Inversion (NOT) operation
3.2.2 OR Operation
3.2.3 AND Operation
3.2.4 Combined OR-AND operations
3.2.5 Truth Table
3.2.6 Symbols
3.2.7 Types of Logic Gates
3.3 Basic Logic Gates 83
3.3.1 The NOT (Inverter) Gate
3.3.2 The OR Gate
3.3.3 The AND Gate
3.3.4 Tristate Logic Gate (Tristate Buffer)
3.4 Universal Logic Gates 91
3.4.1 NAND gate (NAND = Not AND)
3.4.2 NOR gate (NOR = Not OR)
3.5 Special Logic Gates 95
3.5.1 EXOR (EXclusive-OR) Gate
3.5.2 EXNOR (EXclusive-NOR) Gate
3.6 Combinations of Logic Gates 98
3.6.1 Truth Tables and Logic Circuits
3.6.2 NAND gate Equivalents
3.6.3 NOR gate Equivalents
3.7 Electronics Implementation within Digital Logic Gates 101
3.7.1 Classification of Integrated Circuits
3.7.2 TTL and CMOS Logic Levels
3.7.3 DRL and DTL Logic Gates
3.7.4 TTL Logic Gates
3.7.5 Emitter-Coupled Digital Logic Gates
3.7.6 CMOS Gate Circuitry
3.7.7 Inverter Logic Gate
3.7.8 Static Logic Design of NAND, NOR, XOR and XNOR Gates
3.8 Digital Logic Gates Implementation within VHDL 109
3.8.1 NOT Gate Code
3.8.2 AND Gate Code
3.8.3 OR Gate Code
3.9 Exercises: Logic Gates and Logic Circuits 111
4- Boolean Algebra and Karnaugh Maps 113
4.1 Introduction
4.2 Boolean Algebra Rules 114
Two-Valued Boolean Algebra
4.3 Basic Theorems and Properties of Boolean Algebra 114
Duality
Basic Theorems
Operator Precedence
Boolean Functions
Logic Gate Implementation (Basic)
Complement of a Function
4.4 Canonical and Standard Forms 117
Minterms and Maxterms
Minterms (SOP)
Maxterms (POS)
4.5 Simplification of Boolean Functions 120
4.5.1 Product of Sums (POS) Simplification
4.5.2 NAND and NOR Implementation
4.5.3 Don’t Care Conditions
4.6 Karnaugh Map (K-map) 123
4.6.1 K-mapping and Minimization Steps 123
4.6.2 Two variables map
4.6.3 Three variables map
4.6.4 Four variables map
4.6.5 Five variables map
4.6.6 Six variables map
4.7 Case studies 128
4.8 Exercises: Boolean Algebra and Logic Gates 135
5- Data Processing and Arithmetic Circuits 137
5.1 Comparison 137
5.2 Addition 140
5.2.1 Quarter Adder
5.2.2 Half Adder (HA)
5.2.3 Full Adder (FA)
5.2.4 Parallel Adders
5.2.5 Ripple Carry Adder
5.2.6 Carry Look Ahead Adder
5.3 Negative Numbers and Binary Subtraction 154
5.4 Subtraction 157
5.5 Exercises: Decoders, Encoders, and Adders/Subtractors 158
6- Combinational Networks 160
6.1 Decoders 160
6.1.1 Three-to-Eight-Line Decoder
6.1.2 Two-to-Four-Line Decoder with Enable and NANDs
6.1.3 Expanded Realization
6.1.4 BCD to Seven-Segment Decoder 164
6.1.5 Combinational Logic Implementation
6.2 Encoders 174
6.2.1 4-to-2 Bit Binary Encoder
6.2.2 Active High 8-to-3 Line Encoder
6.2.3 Active Low 8-to-3 Line Encoder
6.2.4 Priority Encoder
6.2.5 Eight-to-Three Bit Priority Encoder
6.2.6 Encoder Applications: Positional Encoders
6.3 Multiplexers 191
6.3.1 Two-Input Multiplexer
6.3.2 Four-Input Multiplexer
6.3.3 Combined Multiplexers
6.3.4 Multiplexer Expansion
6.4 Demultiplexers 197
6.4.1 The 1-to-2 Line Decoder/Demultiplexer
6.5 Boolean Functions Realization/ Implementation 198
6.5.1 Three-Variables Function
6.5.2 Four-Variables Function
6.5.3 Multiplexers using Three-State Gates
6.6 Exercices: Decoders, Encoders and Multiplexers 202
References 205
Appendices 206
Appendix-A: Digital Principles of System Design Understanding 206
Appendix-B: Circuits' and Devices' Symbols 213
Appendix-C: Electronic Devices and Circuits: Significant Equations 220
Appendix-D: Laboratory Experiments and Assignments 228
Preface
Abstract: Logic Laboratories
Measuring Instruments
Lab-01: Basic Electronic Instruments and Measurements 234
Lab-02: Oscilloscope and Function Generator 239
Lab-03: Voltage, Current, Resistance and Power Measurements 243
Lab-04: Inverters 259
Lab-05: AND Gates 260
Lab-06: OR Gates 262
Lab-07: NAND and NOR Gates 264
Lab-08: XOR and XNOR Gates 266
Lab-09: Half- and Full-Adders 268
Lab-10: Half- and Full-Subtractors 269
Lab-11: 1’S Complement Adder /Subtractor 270
Lab-12: 2's Complement Adder/Subtractor 271
Lab-13: Multiplexers and Demultiplexers 272
Appendix-E: List of 7400 Series Integrated Circuits 274
E.1 Integrated Circuits Functioning
E.2 Integrated Circuits Pin Configuration
Appendix-F: List of 4000 Series Integrated Circuits 307
F.1 Integrated Circuits Functioning
F.2 Integrated Circuits Pin Configuration

->**********************************25_Mazumder_en.txt
Preface xi
Acknowledgement xv
List of Figures xvii
List of Tables xxix List of Abbreviations xxxi 1 Introduction 1
11 Objectives  1
111 Equationrepresentation  1
112 Hardware platform implementation  3
113 Sequential design  4
114 Data path components 6
115 Backend lectures  6
12 Analog vs Digital 7
13 Digital Design 11
131 Levels of digital design 12
132 What do digital designers do?  13
2 Numeral Systems and BCD codes 17
21 Introduction 18
211 Unary numeral systems 18
212 The positional numeral system, or the place-value system  19
2121 Binary numbers  19
2122 Hexadecimal numbers  20
2123 Octalnumbers  20
2124 Converting from decimal to different bases 21
2125 Converting from one arbitrary base (p) to anotherarbitrarybase(q)  22
22 Addition and Subtraction in the Positional Numeral System  24
23 Negative Numbers in Binary  26
231 Signed magnitude  26
232 The 1’s complement  28
2321 Addition in the 1’s complement  30
2322 Subtraction in the 1’s complement  31
233 The2’scomplement  32
2331 Addition in the 2’s complement  34
2332 Subtraction in the 2’s complement  35
24 Strings of Bits and Binary-Coded Decimal Representations  36
241 The8421BCDcode  36
242 The 2421, 631-1, 84-2-1, and Excess-3 BCD codes  38
243 Thebiquinarycode  39
244 Thegraycode 39
245 BCDsummary  43
25 More on Number Systems  44
26 ConclusionandKeyPoints  46
3 Boolean Algebra and Logic Gates 51
31 Motivation 52
32 HuntingtonPostulates 52
33 Basic Theorems of Boolean Algebra  53
331 Basic postulates with 0 and 1 53
332 Idempotent laws  54
333 The Law of involution  54
334 Complementarity laws  54
335 Commutative laws  55
336 Associative laws  55
337 Distributive laws  55
338 DeMorgan’slaws  56
34 Duality  59
341 What you should know from duality  60
35 Logic Gates for Implementation of Boolean Networks  60
351 AND,OR,andNOT  60
352 Implicantgates  61
353 Otherlogicgates  62
354 Equivalentgates  65
355 Conceptofcompleteness  67
36 CMOSGates  67
37 General Complementary Switching Network  70
38 Conclusion  71
39 KeyPoints 72
4 Timing Diagrams 79
41 NotionofTimingDelayinaCircuit  80
42 DefinitionofPropagationDelay  82
43 TimingDiagramsofaGatedLogic  84
44 The Ring Oscillator: Good Use of Delays  86
45 Glitches and Hazards: Bad Effects Due to Unequal Path Delays 89
451 Correction of the static-1 hazard  90
46 ConclusionandKeyPoints  93
5 Combinational Logic Design Techniques: Part I 99
51 Designing a Digital System from a Problem Statement    100
511 Stairwelllampproblem 100
512 BCD to seven-segment converter  107
513 Eventdetector  110
52 ConclusionandKeyPoints  111
6 Combinational Logic Design Techniques: Part II 115
61 MajorityGateDesign  116
611 SOPimplementation  117
612 POSimplementation  119
613 Self-duality 120
62 Why Different Representations: Two-Level Logic ImplementationStyles  121
621 SOPrepresentations  121
622 POSrepresentations  122
623 Compatible representations for CMOS design  122
63 HardwareDescriptionLanguages 123
631 Majority gate and stairwell lamp verilog Implementation 125
632 Full adder verilog implementation  126
633 Ripplecarryadder  126
64 ConclusionandKeyPoints  127
7 Combinational Logic Minimization 135
71 Representation for Minimization: Summarization  135
711 Intuitivedesignapproach 136
712 Booleanminimization  136 
72 Graphical Method: The Karnaugh Map 
137 73 Three-and Four-Variable Karnaugh Maps for Logic Circuits 139
74 Minimizing with Four-Variable K-maps 142
741 Formaldefinitions 143
742 Example 1: detailed illustration of minimization 743
Example 2: prime implicant definition reinforcement 146
744 Example 3: dealing with “Don’t cares”  146 
75 ConclusionandKeyPoints  149
8 Combinational Building Blocks 155
81 Decoders  55
811 Implementation of larger-bit decoders  156
812 Using decoders to implement boolean functions    158
8121 Example1  58
8122 Example2  58
82 Multiplexers 60
821 Implementation of larger-bit multiplexers  62
822 Using multiplexers to implement boolean functions  163
8221 Example1  163
8222 Example2  167
83 MSIBuildingBlocks  167
831 Decoders  167
8311 The 74139 decoder  167
8312 The 74138 Decoder  170
832 Tri-statebuffers 170
8321 Application  171
8322 The 74541 three-state driver  173 
833 Encoders  173
8331 The 74148 priority encoder  174
8332 Verilog implementation  176 
834 Multiplexers  178
835 Paritycircuits  178
836 Comparisoncircuits  181
8361 Equality  181
8362 Greater than and less than  182
8363 The 74682 magnitude comparator IC    182
84 Conclusion  183
85 KeyPoints 183
9 Foundations of Sequential Design: Part I 191
91 TaxonomyofSequentialModels  191
911 Themealymachine 191
912 Themooremachine 193
92 Flip-Flops 193
921 Operation of flip-flops and their applications  193
922 Classification of flip-flops  194
9221 S-Rflip-flop  194
92211 Characteristic table  194
92212 Statediagram  196
9222 Tflip-flop  197
92221 Characteristic table  197
92222 Statediagram  198
9223 J-K flip-flop1 198
92231 Characteristic table  199
92232 Statediagram  200
9224 Dflip-flop  200
93 ConclusionandKeyPoints  201
10 Foundations of Sequential Design: Part II 207
101 Gate Implementation of Flip-Flops and Timing Diagrams   208
1011 Simple inverters without feedback  208
1012 Single inverter with feedback (oscillator)  208
1013 Two inverters with feedback (flip-flop)  209
1014 S-Rlatch  210
10141 S-R latch timing diagram  211
10142 Problems with the S-R latch  213
102ClockedFlip-Flops  214
1021 ClockedS-Rflip-flop 215
1022 ClockedJ-Kflip-flop  216
10221 J-K flip-flop timing diagram  217
10222 Problems with the J-K flip-flop  218
1023 Solutions to the race-around problem  219
10231 Narrowing the clock pulse width  220
10232 Separating the inputs and outputs of the flip-flop  222
102321 Master-Slave D flip-flop  223
102322 Master-Slave J-K flip-flop  224
1024 IEEE symbols and flip-flop types  228
1025 Timing analysis of flip-flop problems  230
10251 Example 1: timing diagram of a J-K flip-flop 230
10252 Example 2: timing diagram of J-K flip-flops configured as a counter/binary divider 231
10253 Example 3: Timing diagram of D flip-flops configured as a ring counter  232
1026 Effectofthewidthofthesetpulse  233
1027 Dealing with metastability and asynchronous inputs  234
103ConclusionandKeyPoint 235
104ProblemsonFlip-Flops 236
Index 243
About the Authors 247